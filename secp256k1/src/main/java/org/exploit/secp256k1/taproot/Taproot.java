package org.exploit.secp256k1.taproot;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.util.Hash;

import java.util.Objects;

public final class Taproot {
    private Taproot() {}

    private static final Secp256k1CurveParams CURVE_PARAMS = new Secp256k1CurveParams();

    public static final class TweakPubkeyResult {
        private final int parity;
        private final byte[] xOnlyPubkey;

        public TweakPubkeyResult(int parity, byte[] xOnlyPubkey) {
            this.parity = parity;
            this.xOnlyPubkey = Objects.requireNonNull(xOnlyPubkey, "xOnlyPubkey");
        }

        public int getParity() {
            return parity;
        }

        public byte[] getXOnlyPubkey() {
            return xOnlyPubkey;
        }
    }

    public static TweakPubkeyResult taprootTweakPubkey(byte[] xOnlyPubkey32, byte[] h) {
        Objects.requireNonNull(xOnlyPubkey32, "xOnlyPubkey32");
        Objects.requireNonNull(h, "h");
        if (xOnlyPubkey32.length != 32) {
            throw new IllegalArgumentException("xOnlyPubkey32 must be 32 bytes");
        }

        var tBytes = Hash.taggedHash(concat(xOnlyPubkey32, h), "TapTweak");
        var t = intFrom32(tBytes);

        var n = CURVE_PARAMS.getCurveOrder();
        var g = CURVE_PARAMS.getG();

        if (t.compareTo(n) >= 0) {
            throw new IllegalArgumentException("TapTweak scalar t >= n");
        }

        PointOps<Secp256k1PointOps> p = liftX(new BigInt(1, xOnlyPubkey32));
        if (p == null) {
            throw new IllegalArgumentException("Invalid x-only pubkey (lift_x failed)");
        }

        PointOps<Secp256k1PointOps> Q = p.add(g.mul(t).normalize()).normalize();
        var parity = hasEvenY(Q) ? 0 : 1;
        var xQ = xOnly(Q);

        return new TweakPubkeyResult(parity, xQ);
    }

    public static byte[] taprootTweakSecretKey(byte[] sec, byte[] h) {
        Objects.requireNonNull(sec, "seckey32");
        Objects.requireNonNull(h, "h");
        if (sec.length != 32) {
            throw new IllegalArgumentException("seckey32 must be 32 bytes");
        }

        var n = CURVE_PARAMS.getCurveOrder();

        var x0 = intFrom32(sec);
        if (x0.signum() <= 0 || x0.compareTo(n) >= 0) {
            throw new IllegalArgumentException("Invalid seckey (not in 1..n-1)");
        }

        PointOps<Secp256k1PointOps> p = CURVE_PARAMS.getG().mul(x0).normalize();
        var xEven = hasEvenY(p) ? x0 : n.subtract(x0);

        var tweakBytes = Hash.taggedHash(concat(xOnly(p), h), "TapTweak");
        var t = intFrom32(tweakBytes);

        if (t.compareTo(n) >= 0) {
            throw new IllegalArgumentException("TapTweak scalar t >= n");
        }

        var xTweaked = xEven.add(t).mod(n);
        if (BigInt.ZERO.equals(xTweaked)) {
            throw new IllegalArgumentException("Tweaked seckey is 0 (invalid)");
        }

        return xTweaked.toUnsignedByteArray(32);
    }

    public static byte[] xOnly(PointOps<Secp256k1PointOps> p) {
        var x = p.normalize().getAffineX();
        return x.toUnsignedByteArray(32);
    }

    public static boolean hasEvenY(PointOps<Secp256k1PointOps> p) {
        var y = p.normalize().getAffineY();
        return !y.testBit(0);
    }

    private static BigInt intFrom32(byte[] bytes) {
        return new BigInt(1, bytes);
    }

    private static byte[] concat(byte[] a, byte[] b) {
        var out = new byte[a.length + b.length];
        System.arraycopy(a, 0, out, 0, a.length);
        System.arraycopy(b, 0, out, a.length, b.length);
        return out;
    }

    public static Secp256k1PointOps liftX(BigInt x) {
        var p = Secp256k1CurveParams.Q;
        if (x.compareTo(BigInt.ZERO) < 0 || x.compareTo(p) >= 0)
            return null;

        // y^2 = x^3 + 7 mod p
        var alpha = x.modPow(BigInt.valueOf(3), p).add(BigInt.valueOf(7)).mod(p);

        // y = sqrt(alpha) mod p
        var beta = sqrtModP(alpha, p);
        if (beta == null)
            return null;

        var y = beta.testBit(0) ? p.subtract(beta) : beta;

        return CURVE_PARAMS.createPoint(x, y);
    }

    public static BigInt sqrtModP(BigInt a, BigInt p) {
        if (!p.testBit(0) || !p.testBit(1))
            throw new IllegalArgumentException("p must be congruent to 3 mod 4 (secp256k1)");

        var exp = p.add(BigInt.ONE).shiftRight(2);
        var sqrt = a.modPow(exp, p);

        if (sqrt.multiply(sqrt).mod(p).compareTo(a.mod(p)) != 0) {
            return null;
        }

        return sqrt;
    }
}