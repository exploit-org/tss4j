package org.exploit.secp256k1.suite;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.secp256k1.model.FpPoint;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public final class Secp256k1XmdSha256SSWUROSuite {
    private Secp256k1XmdSha256SSWUROSuite() {}
    
    public static final byte[] DST = "secp256k1_XMD:SHA-256_SSWU_RO_".getBytes(StandardCharsets.US_ASCII);

    private static final Secp256k1CurveParams CURVE_PARAMS = new Secp256k1CurveParams();

    private static final int L = 48;
    private static final int m = 1;

    private static final BigInt P = Secp256k1CurveParams.FIELD_P;

    private static final BigInt K10 = new BigInt("8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", 16).mod(P);
    private static final BigInt K11 = new BigInt("7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", 16).mod(P);
    private static final BigInt K12 = new BigInt("534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", 16).mod(P);
    private static final BigInt K13 = new BigInt("8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c", 16).mod(P);

    private static final BigInt K20 = new BigInt("d35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", 16).mod(P);
    private static final BigInt K21 = new BigInt("edadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", 16).mod(P);

    private static final BigInt K30 = new BigInt("4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", 16).mod(P);
    private static final BigInt K31 = new BigInt("c75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", 16).mod(P);
    private static final BigInt K32 = new BigInt("29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", 16).mod(P);
    private static final BigInt K33 = new BigInt("2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84", 16).mod(P);

    private static final BigInt K40 = new BigInt("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", 16).mod(P);
    private static final BigInt K41 = new BigInt("7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", 16).mod(P);
    private static final BigInt K42 = new BigInt("6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", 16).mod(P);

    private static final BigInt Z = new BigInt("-11").mod(P);
    private static final BigInt A_PRIME = new BigInt("3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533", 16).mod(P);
    private static final BigInt B_PRIME = new BigInt("1771").mod(P);

    public static FpPoint mapToCurveSimpleSwu(BigInt u) {
        u = mod(u);
        var u2 = mod(u.multiply(u));
        var u4 = mod(u2.multiply(u2));

        var z2 = mod(Z.multiply(Z));
        var tv1 = mod(z2.multiply(u4).add(Z.multiply(u2)));
        tv1 = inv0(tv1);

        var minusBOverA = mod(B_PRIME.negate().multiply(inv0(A_PRIME)));
        var x1 = mod(minusBOverA.multiply(BigInt.ONE.add(tv1)));

        if (tv1.equals(BigInt.ZERO)) {
            x1 = mod(B_PRIME.multiply(inv0(mod(Z.multiply(A_PRIME)))));
        }

        var gx1 = mod(x1.multiply(x1).multiply(x1).add(A_PRIME.multiply(x1)).add(B_PRIME));

        var x2 = mod(Z.multiply(u2).multiply(x1));
        var gx2 = mod(x2.multiply(x2).multiply(x2).add(A_PRIME.multiply(x2)).add(B_PRIME));

        BigInt x, y;
        if (isSquare(gx1)) {
            x = x1;
            y = sqrt(gx1);
        } else {
            x = x2;
            y = sqrt(gx2);
        }

        if (sgn0(u) != sgn0(y)) y = mod(y.negate());
        return new FpPoint(x, y);
    }

    public static Secp256k1PointOps isoMapToSecp256k1(FpPoint pPrime) {
        var xp = mod(pPrime.x());
        var yp = mod(pPrime.y());

        var xp2 = mod(xp.multiply(xp));
        var xp3 = mod(xp2.multiply(xp));

        var xNum = mod(K13.multiply(xp3).add(K12.multiply(xp2)).add(K11.multiply(xp)).add(K10));
        var xDen = mod(xp2.add(K21.multiply(xp)).add(K20));
        var x = mod(xNum.multiply(inv0(xDen)));

        var yNum = mod(K33.multiply(xp3).add(K32.multiply(xp2)).add(K31.multiply(xp)).add(K30));
        var yDen = mod(xp3.add(K42.multiply(xp2)).add(K41.multiply(xp)).add(K40));
        var y = mod(yp.multiply(yNum).multiply(inv0(yDen)));

        return CURVE_PARAMS.createPoint(x, y);
    }

    public static Secp256k1PointOps hashToCurve(byte[] msg, byte[] dst) {
        var u = hashToFieldSecp256k1XmdSha256(msg, dst, 2);

        var q0 = mapToCurveSimpleSwu(u[0]);
        var q1 = mapToCurveSimpleSwu(u[1]);

        var p0 = isoMapToSecp256k1(q0);
        var p1 = isoMapToSecp256k1(q1);

        return p0.add(p1).normalize();
    }

    public static Secp256k1PointOps hashToCurve(byte[] msg) {
        return hashToCurve(msg, DST);
    }

    public static BigInt[] hashToFieldSecp256k1XmdSha256(byte[] msg, byte[] dst, int count) {
        var p = Secp256k1CurveParams.FIELD_P;

        int lenInBytes = count * m * L;
        byte[] uniform = Secp256k1.expandMessageXmd("SHA-256", 64, msg, dst, lenInBytes);

        var out = new BigInt[count];
        for (int i = 0; i < count; i++) {
            int off = i * L;
            byte[] tv = Arrays.copyOfRange(uniform, off, off + L);
            out[i] = new BigInt(1, tv).mod(p);
        }
        return out;
    }

    private static BigInt mod(BigInt x) {
        return x.mod(P);
    }

    private static BigInt inv0(BigInt a) {
        a = mod(a);
        if (a.equals(BigInt.ZERO)) return BigInt.ZERO;
        return a.modInverseSec(P);
    }

    private static boolean isSquare(BigInt a) {
        a = mod(a);
        if (a.equals(BigInt.ZERO)) return true;

        var exp = P.subtract(BigInt.ONE).shiftRight(1);
        return a.modPowSec(exp, P).equals(BigInt.ONE);
    }

    private static BigInt sqrt(BigInt a) {
        a = mod(a);
        if (a.equals(BigInt.ZERO)) return BigInt.ZERO;

        var exp = P.add(BigInt.ONE).shiftRight(2);
        var y = a.modPowSec(exp, P);

        if (!mod(y.multiply(y)).equals(a))
            throw new IllegalStateException("sqrt failed");

        return y;
    }

    private static int sgn0(BigInt x) {
        return mod(x).testBit(0) ? 1 : 0;
    }
}
