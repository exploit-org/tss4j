package org.exploit.secp256k1.jna;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import org.bouncycastle.util.encoders.Hex;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.secp256k1.jna.struct.Secp256k1Keypair;
import org.exploit.secp256k1.jna.struct.Secp256k1Pub;
import org.exploit.secp256k1.jna.struct.Secp256k1XOnlyPub;

public interface LibSecp256k1 extends Library {
    LibSecp256k1 INSTANCE = Native.load("secp256k1", LibSecp256k1.class);

    Secp256k1PointOps GENERATOR_H = new Secp256k1PointOps(Hex.decode("0350929B74C1A04954B78B4B6035E97A5E078A5A0F28EC96D547BFEE9ACE803AC0"));

    int SECP256K1_FLAGS_TYPE_CONTEXT = 1;
    int SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
    int SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
    int SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
    int SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;

    int SECP256K1_SCHNORRSIG_BYTES = 64;
    int SECP256K1_XONLY_PUBKEY_BYTES = 32;

    int SECP256K1_CONTEXT_NONE  = SECP256K1_FLAGS_TYPE_CONTEXT;
    int SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
    int SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
    int SECP256K1_CONTEXT_SIGN_VERIFY = SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN;

    int SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
    int SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;

    Pointer secp256k1_context_create(int flags);
    void secp256k1_context_destroy(Pointer ctx);

    int secp256k1_ecdsa_recoverable_signature_parse_compact(Pointer ctx, byte[] sig, byte[] input64, int recid);

    int secp256k1_ecdsa_recoverable_signature_serialize_compact(Pointer ctx, byte[] output64, int[] recid, byte[] sig);

    int secp256k1_ecdsa_recover(Pointer ctx, byte[] pubkey, byte[] sig, byte[] msg32);
    int secp256k1_ec_pubkey_parse(Pointer ctx, byte[] pubkey, byte[] input, long inputlen);
    int secp256k1_ec_pubkey_serialize(Pointer ctx, byte[] output, long[] outputlen, byte[] pubkey, int flags);
    int secp256k1_ec_pubkey_combine(Pointer ctx, byte[] output, Pointer[] inputPubkeyPtrs, long nPubkeys);

    int secp256k1_ec_pubkey_negate(Pointer ctx, byte[] pubkey);
    int secp256k1_ec_pubkey_tweak_mul(Pointer ctx, byte[] pubkey, byte[] tweak32);
    int secp256k1_ec_pubkey_create(Pointer ctx, byte[] output, byte[] seckey32);

    int secp256k1_context_randomize(Pointer ctx, byte[] seed32);

    int secp256k1_ec_seckey_verify(Pointer ctx, byte[] seckey32);

    int secp256k1_ecdsa_sign_recoverable(Pointer ctx, byte[] recsig, byte[] msg32, byte[] seckey32, Pointer noncefp, Pointer ndata);

    int secp256k1_xonly_pubkey_from_pubkey(
            Pointer ctx,
            Secp256k1XOnlyPub xonlyOut,
            int[] pkParity,
            Secp256k1Pub pubIn);

    int secp256k1_keypair_create(Pointer ctx, byte[] keypair96, byte[] seckey32);

    int secp256k1_keypair_xonly_pub(Pointer ctx, byte[] pubkey32, int[] pk_parity, Secp256k1Keypair keypair96);

    int secp256k1_xonly_pubkey_parse(Pointer ctx, Pointer pubkey, byte[] input32);

    int secp256k1_xonly_pubkey_serialize(Pointer ctx, byte[] output32, Secp256k1XOnlyPub pubkey);

    int secp256k1_xonly_pubkey_tweak_add_check(byte[] tweak32, byte[] input_pubkey32, byte[] output_pubkey32, int pk_parity);

    int secp256k1_xonly_pubkey_tweak_add(
            Pointer ctx,
            Secp256k1Pub outPub,
            Secp256k1XOnlyPub internalPub,
            byte[] tweak32);

    int secp256k1_keypair_create(
            Pointer ctx,
            Secp256k1Keypair keypair,
            byte[] seckey32
    );

    int secp256k1_keypair_xonly_pub(
            Pointer ctx,
            Secp256k1XOnlyPub xonly,
            int[] parity,
            Secp256k1Keypair keypair);

    int secp256k1_xonly_pubkey_parse(
            Pointer ctx,
            Secp256k1XOnlyPub pubkey,
            byte[] x32);

    int secp256k1_schnorrsig_sign32(
            Pointer ctx,
            byte[] sig64,
            byte[] msg32,
            Secp256k1Keypair keypair,
            byte[] auxRand32
    );

    int secp256k1_schnorrsig_verify(
            Pointer ctx,
            byte[] sig64,
            byte[] msg,
            NativeLong msgLen,
            Secp256k1XOnlyPub pubkey
    );

    int secp256k1_keypair_xonly_tweak_add(
            Pointer ctx,
            Secp256k1Keypair keypair,
            byte[] tweak32
    );
}