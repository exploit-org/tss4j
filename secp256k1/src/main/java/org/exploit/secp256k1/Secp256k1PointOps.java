package org.exploit.secp256k1;

import com.sun.jna.Memory;
import com.sun.jna.Pointer;
import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.jna.Secp256k1;
import org.exploit.secp256k1.jna.Secp256k1Context;
import org.exploit.tss.curve.ec.WeierstrassPointOps;

import java.util.Arrays;
import java.util.HexFormat;

@AllArgsConstructor
public class Secp256k1PointOps implements WeierstrassPointOps<Secp256k1PointOps> {
    public static final Secp256k1PointOps INFINITY = new Secp256k1PointOps(new byte[33]);

    public static final byte[] COMPRESSED_INFINITY = new byte[33];
    public static final byte[] UNCOMPRESSED_INFINITY = new byte[65];

    private final byte[] encoded;

    private boolean isInfinityEncoded() {
        return Arrays.equals(encoded, COMPRESSED_INFINITY);
    }

    @Override
    public Secp256k1PointOps add(Secp256k1PointOps q) {
        if (this.isInfinityEncoded()) return q;
        if (q.isInfinityEncoded()) return this;

        var pk1 = parse();
        var pk2 = q.parse();

        try (var m1 = new Memory(pk1.length); var m2 = new Memory(pk2.length)) {
            m1.write(0, pk1, 0, pk1.length);
            m2.write(0, pk2, 0, pk2.length);

            var inputs = new Pointer[]{m1, m2};

            var out = new byte[64];
            var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_combine(
                    Secp256k1Context.CTX,
                    out,
                    inputs,
                    inputs.length
            );
            if (ok == 0) throw new IllegalStateException("Point addition failed");

            return new Secp256k1PointOps(serialize(out, true));
        }
    }

    @Override
    public Secp256k1PointOps dbl() {
        if (this.isInfinityEncoded()) return this;
        return add(this);
    }

    @Override
    public Secp256k1PointOps sub(Secp256k1PointOps q) {
        if (q.isInfinityEncoded())
            return this;

        if (this.equals(q))
            return INFINITY;

        return add(q.negate());
    }

    @Override
    public Secp256k1PointOps mul(BigInt k) {
        if (k == null)
            throw new IllegalArgumentException("Scalar cannot be null");

        var kMod = k.mod(Secp256k1CurveParams.CURVE_ORDER);
        if (kMod.signum() == 0) return INFINITY;
        if (kMod.equals(BigInt.ONE)) return this;

        var pk = parse();
        var scalar = to32(kMod);
        var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_tweak_mul(Secp256k1Context.CTX, pk, scalar);

        if (ok == 0)
            throw new IllegalStateException("Scalar multiplication failed");

        return new Secp256k1PointOps(serialize(pk, true));
    }

    @Override
    public Secp256k1PointOps normalize() {
        return this;
    }

    @Override
    public Secp256k1PointOps negate() {
        if (this.isInfinityEncoded()) return this;

        var pk = parse();
        var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_negate(
                Secp256k1Context.CTX, pk);
        if (ok == 0) throw new IllegalStateException("Negation failed");

        return new Secp256k1PointOps(serialize(pk, true));
    }

    @Override
    public boolean isValid() {
        try {
            parse();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public byte[] encode(boolean compressed) {
        if (compressed) {
            return encoded.clone();
        }
        if (isInfinityEncoded()) {
            return UNCOMPRESSED_INFINITY.clone();
        }
        var pk = parse();
        return serialize(pk, false);
    }

    public static byte[] serialize(byte[] pubkey64, boolean compressed) {
        var out = new byte[compressed ? 33 : 65];
        long[] len = {out.length};
        var flags = compressed
                ? Secp256k1.SECP256K1_EC_COMPRESSED
                : Secp256k1.SECP256K1_EC_UNCOMPRESSED;

        var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_serialize(Secp256k1Context.CTX, out, len, pubkey64, flags);
        if (ok == 0) throw new IllegalStateException("Serialize failed");
        return out;
    }

    private byte[] parse() {
        var pk = new byte[64];
        var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_parse(Secp256k1Context.CTX, pk, encoded, encoded.length);
        if (ok == 0) throw new IllegalStateException("Invalid secp256k1 point");
        return pk;
    }

    private static byte[] to32(BigInt k) {
        var be = k.mod(Secp256k1CurveParams.CURVE_ORDER).toByteArray();
        var out = new byte[32];
        var srcPos = Math.max(be.length - 32, 0);
        System.arraycopy(be, srcPos, out, 32 - (be.length - srcPos),
                be.length - srcPos);
        return out;
    }

    @Override
    public boolean equals(Object o) {
        return (o instanceof Secp256k1PointOps other) && Arrays.equals(encoded, other.encoded);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(encoded);
    }

    @Override
    public String toString() {
        return HexFormat.of().formatHex(encoded);
    }

    public static Secp256k1PointOps baseMul(BigInt k) {
        if (k == null)
            throw new IllegalArgumentException("Scalar cannot be null");

        var kMod = k.mod(Secp256k1CurveParams.CURVE_ORDER);
        if (kMod.signum() == 0) return INFINITY;

        var out = new byte[64];
        var seckey = to32(kMod);

        var ok = Secp256k1.INSTANCE.secp256k1_ec_pubkey_create(
                Secp256k1Context.CTX, out, seckey);
        if (ok == 0) throw new IllegalStateException("Base-mul failed");

        return new Secp256k1PointOps(serialize(out, true));
    }

    public static Secp256k1PointOps fromBytes(byte[] buf) {
        return new Secp256k1PointOps(buf.clone());
    }

    @Override
    public BigInt getAffineX() {
        ensureNotInfinity();
        var u = encode(false);
        return toUnsignedBigInt(u, 1);
    }

    @Override
    public BigInt getAffineY() {
        ensureNotInfinity();
        var u = encode(false);
        return toUnsignedBigInt(u, 33);
    }

    private static BigInt toUnsignedBigInt(byte[] src, int offset) {
        var mag = Arrays.copyOfRange(src, offset, offset + 32);
        return new BigInt(1, mag);
    }

    private void ensureNotInfinity() {
        if (isInfinityEncoded())
            throw new IllegalStateException("Infinity has no affine coordinates");
    }
}