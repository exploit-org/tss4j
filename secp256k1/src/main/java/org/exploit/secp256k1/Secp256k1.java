package org.exploit.secp256k1;

import com.sun.jna.NativeLong;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.jna.LibSecp256k1;
import org.exploit.secp256k1.jna.struct.Secp256k1Keypair;
import org.exploit.secp256k1.jna.struct.Secp256k1Pub;
import org.exploit.secp256k1.jna.struct.Secp256k1XOnlyPub;
import org.exploit.tss.key.RawKeyPair;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.security.SecureRandom;
import java.util.Arrays;

import static org.exploit.secp256k1.Secp256k1PointOps.to32;
import static org.exploit.secp256k1.jna.LibSecp256k1.INSTANCE;
import static org.exploit.secp256k1.jna.Secp256k1Context.CTX;

public final class Secp256k1 {
    private Secp256k1() {}

    private static final SecureRandom RNG = new SecureRandom();

    public static RawKeyPair generateKeyPair() {
        var sk = new byte[32];
        do { RNG.nextBytes(sk); }
        while (INSTANCE.secp256k1_ec_seckey_verify(CTX, sk) != 1);

        var pub = new byte[64];
        if (INSTANCE.secp256k1_ec_pubkey_create(CTX, pub, sk) != 1)
            throw new IllegalStateException();

        var out = new byte[33];
        long[] outLen = { out.length };

        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, out, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1)
            throw new IllegalStateException();

        return new RawKeyPair(out, sk);
    }

    public static byte[] signRecoverable(byte[] msg32, byte[] sk) {
        var recSig = new byte[65];

        if (INSTANCE.secp256k1_ecdsa_sign_recoverable(
                CTX, recSig, msg32, sk, null, null) != 1)
            throw new IllegalStateException();

        var sig64 = new byte[64];
        var recid = new int[1];

        if (INSTANCE.secp256k1_ecdsa_recoverable_signature_serialize_compact(
                CTX, sig64, recid, recSig) != 1)
            throw new IllegalStateException();

        var out = Arrays.copyOf(sig64, 65);
        out[64] = (byte) recid[0];
        return out;
    }

    public static boolean verifyRecoverable(byte[] msg32, byte[] sig65, byte[] expectPk33) {
        var recSig = new byte[65];
        if (INSTANCE.secp256k1_ecdsa_recoverable_signature_parse_compact(CTX, recSig, Arrays.copyOf(sig65, 64), sig65[64]) != 1)
            return false;

        var pub = new byte[64];
        if (INSTANCE.secp256k1_ecdsa_recover(CTX, pub, recSig, msg32) != 1)
            return false;

        var ser = new byte[33];

        long[] outLen = { ser.length };
        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, ser, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1)
            throw new IllegalStateException();

        return Arrays.equals(ser, expectPk33);
    }

    public static byte[] getPublicKey(byte[] sk32) {
        var pub = new byte[64];
        if (INSTANCE.secp256k1_ec_pubkey_create(CTX, pub, sk32) != 1) {
            throw new IllegalArgumentException("Invalid secret key");
        }

        var out = new byte[33];
        long[] outLen = { out.length };
        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, out, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1) {
            throw new IllegalStateException("Failed to serialize public key");
        }

        return out;
    }

    public static XOnlyPublicKey xonlyFromSecret(byte[] sk32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);

        var xonly = new Secp256k1XOnlyPub();
        var parity = new int[1];
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonly, parity, kp);
        xonly.read();

        var xonlyBytes = new byte[32];
        if (INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, xonlyBytes, xonly) != 1) {
            throw new IllegalStateException("Failed to serialize xonly pubkey");
        }

        return new XOnlyPublicKey(xonlyBytes, parity[0]);
    }

    public static byte[] schnorrSign(byte[] msg32, byte[] sk32, byte[] auxRand32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);
        var sig64 = new byte[64];
        INSTANCE.secp256k1_schnorrsig_sign32(CTX, sig64, msg32, kp, auxRand32);
        return sig64;
    }

    public static byte[] schnorrSign(byte[] msg32, byte[] sk32) {
        return schnorrSign(msg32, sk32, new byte[32]);
    }

    public static boolean schnorrVerify(byte[] msg32, byte[] sig64, byte[] xonly32) {
        var pub = new Secp256k1XOnlyPub();
        if (INSTANCE.secp256k1_xonly_pubkey_parse(CTX, pub, xonly32) != 1) {
            throw new IllegalArgumentException("Invalid xonly public key");
        }

        return INSTANCE.secp256k1_schnorrsig_verify(
                CTX, sig64, msg32,
                new NativeLong(msg32.length),
                pub) == 1;
    }

    public static byte[] tapTweak32(byte[] xonly32, byte[] merkleRoot32) {
        return Hash.taggedHash(Bytes.concat(xonly32, merkleRoot32), "TapTweak");
    }

    public static byte[] taprootTweakedXonly(byte[] internalXonly32, byte[] merkleRoot32) {
        var internal = new Secp256k1XOnlyPub();
        if (INSTANCE
                .secp256k1_xonly_pubkey_parse(CTX, internal, internalXonly32) != 1)
            throw new IllegalArgumentException("Invalid internal xonly pubkey");

        var tweak32 = tapTweak32(internalXonly32, merkleRoot32);

        var tweakedFull = new Secp256k1Pub();
        if (INSTANCE
                .secp256k1_xonly_pubkey_tweak_add(CTX, tweakedFull, internal, tweak32) != 1)
            throw new IllegalStateException("xonly tweak failed");

        var tweakedXonly = new Secp256k1XOnlyPub();
        var parity = new int[]{0};
        INSTANCE.secp256k1_xonly_pubkey_from_pubkey(CTX, tweakedXonly, parity, tweakedFull);

        var out32 = new byte[32];
        INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, out32, tweakedXonly);
        return out32;
    }


    public static byte[] taprootSign(byte[] msg32, byte[] sk32, byte[] merkleRoot32, byte[] auxRand32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);

        var parity = new int[]{0};
        var xonlyTmp = new Secp256k1XOnlyPub();
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonlyTmp, parity, kp);

        if (parity[0] == 1) {
            var n = Secp256k1CurveParams.CURVE_ORDER;
            var d = new BigInt(1, sk32);
            d = n.subtract(d).mod(n);
            var evenSk32 = to32(d);

            INSTANCE.secp256k1_keypair_create(CTX, kp, evenSk32);
        }

        var internalX32 = new byte[32];
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonlyTmp, null, kp);
        INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, internalX32, xonlyTmp);

        var tweak32 = tapTweak32(internalX32, merkleRoot32);

        if (INSTANCE.secp256k1_keypair_xonly_tweak_add(CTX, kp, tweak32) != 1)
            throw new IllegalStateException("Keypair tweak failed");

        var sig64 = new byte[64];
        INSTANCE.secp256k1_schnorrsig_sign32(CTX, sig64, msg32, kp, auxRand32);
        return sig64;
    }


    public static byte[] taprootSign(byte[] msg32, byte[] sk32, byte[] merkleRoot32) {
        return taprootSign(msg32, sk32, merkleRoot32, new byte[32]);
    }

    public static boolean taprootVerify(byte[] msg32, byte[] sig64, byte[] xonly32, byte[] merkleRoot32) {
        var tweakedXonly = taprootTweakedXonly(xonly32, merkleRoot32);

        var pub = new Secp256k1XOnlyPub();
        if (INSTANCE.secp256k1_xonly_pubkey_parse(CTX, pub, tweakedXonly) != 1)
            return false;

        return INSTANCE.secp256k1_schnorrsig_verify(
                CTX, sig64, msg32, new NativeLong(msg32.length), pub) == 1;
    }
}