package org.exploit.secp256k1;

import com.sun.jna.NativeLong;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.jna.LibSecp256k1;
import org.exploit.secp256k1.jna.struct.Secp256k1Keypair;
import org.exploit.secp256k1.jna.struct.Secp256k1Pub;
import org.exploit.secp256k1.jna.struct.Secp256k1XOnlyPub;
import org.exploit.tss.key.RawKeyPair;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;

import static org.exploit.secp256k1.Secp256k1PointOps.to32;
import static org.exploit.secp256k1.jna.LibSecp256k1.INSTANCE;
import static org.exploit.secp256k1.jna.Secp256k1Context.CTX;
import static org.exploit.tss.util.Bytes.concat;

public final class Secp256k1 {
    private Secp256k1() {}

    private static final SecureRandom RNG = new SecureRandom();

    public static RawKeyPair generateKeyPair() {
        var sk = new byte[32];
        do { RNG.nextBytes(sk); }
        while (INSTANCE.secp256k1_ec_seckey_verify(CTX, sk) != 1);

        var pub = new byte[64];
        if (INSTANCE.secp256k1_ec_pubkey_create(CTX, pub, sk) != 1)
            throw new IllegalStateException();

        var out = new byte[33];
        long[] outLen = { out.length };

        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, out, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1)
            throw new IllegalStateException();

        return new RawKeyPair(out, sk);
    }

    public static byte[] signRecoverable(byte[] msg32, byte[] sk) {
        var recSig = new byte[65];

        if (INSTANCE.secp256k1_ecdsa_sign_recoverable(
                CTX, recSig, msg32, sk, null, null) != 1)
            throw new IllegalStateException();

        var sig64 = new byte[64];
        var recid = new int[1];

        if (INSTANCE.secp256k1_ecdsa_recoverable_signature_serialize_compact(
                CTX, sig64, recid, recSig) != 1)
            throw new IllegalStateException();

        var out = Arrays.copyOf(sig64, 65);
        out[64] = (byte) recid[0];
        return out;
    }

    public static boolean verifyRecoverable(byte[] msg32, byte[] sig65, byte[] expectPk33) {
        var recSig = new byte[65];
        if (INSTANCE.secp256k1_ecdsa_recoverable_signature_parse_compact(CTX, recSig, Arrays.copyOf(sig65, 64), sig65[64]) != 1)
            return false;

        var pub = new byte[64];
        if (INSTANCE.secp256k1_ecdsa_recover(CTX, pub, recSig, msg32) != 1)
            return false;

        var ser = new byte[33];

        long[] outLen = { ser.length };
        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, ser, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1)
            throw new IllegalStateException();

        return Arrays.equals(ser, expectPk33);
    }

    public static byte[] getPublicKey(byte[] sk32) {
        var pub = new byte[64];
        if (INSTANCE.secp256k1_ec_pubkey_create(CTX, pub, sk32) != 1) {
            throw new IllegalArgumentException("Invalid secret key");
        }

        var out = new byte[33];
        long[] outLen = { out.length };
        if (INSTANCE.secp256k1_ec_pubkey_serialize(CTX, out, outLen, pub, LibSecp256k1.SECP256K1_EC_COMPRESSED) != 1) {
            throw new IllegalStateException("Failed to serialize public key");
        }

        return out;
    }

    public static XOnlyPublicKey xonlyFromSecret(byte[] sk32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);

        var xonly = new Secp256k1XOnlyPub();
        var parity = new int[1];
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonly, parity, kp);
        xonly.read();

        var xonlyBytes = new byte[32];
        if (INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, xonlyBytes, xonly) != 1) {
            throw new IllegalStateException("Failed to serialize xonly pubkey");
        }

        return new XOnlyPublicKey(xonlyBytes, parity[0]);
    }

    public static byte[] schnorrSign(byte[] msg32, byte[] sk32, byte[] auxRand32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);
        var sig64 = new byte[64];
        INSTANCE.secp256k1_schnorrsig_sign32(CTX, sig64, msg32, kp, auxRand32);
        return sig64;
    }

    public static byte[] schnorrSign(byte[] msg32, byte[] sk32) {
        return schnorrSign(msg32, sk32, new byte[32]);
    }

    public static boolean schnorrVerify(byte[] msg32, byte[] sig64, byte[] xonly32) {
        var pub = new Secp256k1XOnlyPub();
        if (INSTANCE.secp256k1_xonly_pubkey_parse(CTX, pub, xonly32) != 1) {
            throw new IllegalArgumentException("Invalid xonly public key");
        }

        return INSTANCE.secp256k1_schnorrsig_verify(
                CTX, sig64, msg32,
                new NativeLong(msg32.length),
                pub) == 1;
    }

    public static byte[] tapTweak32(byte[] xonly32, byte[] merkleRoot32) {
        return Hash.taggedHash(concat(xonly32, merkleRoot32), "TapTweak");
    }

    public static byte[] taprootTweakedXonly(byte[] internalXonly32, byte[] merkleRoot32) {
        var internal = new Secp256k1XOnlyPub();
        if (INSTANCE
                .secp256k1_xonly_pubkey_parse(CTX, internal, internalXonly32) != 1)
            throw new IllegalArgumentException("Invalid internal xonly pubkey");

        var tweak32 = tapTweak32(internalXonly32, merkleRoot32);

        var tweakedFull = new Secp256k1Pub();
        if (INSTANCE
                .secp256k1_xonly_pubkey_tweak_add(CTX, tweakedFull, internal, tweak32) != 1)
            throw new IllegalStateException("xonly tweak failed");

        var tweakedXonly = new Secp256k1XOnlyPub();
        var parity = new int[]{0};
        INSTANCE.secp256k1_xonly_pubkey_from_pubkey(CTX, tweakedXonly, parity, tweakedFull);

        var out32 = new byte[32];
        INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, out32, tweakedXonly);
        return out32;
    }


    public static byte[] taprootSign(byte[] msg32, byte[] sk32, byte[] merkleRoot32, byte[] auxRand32) {
        var kp = new Secp256k1Keypair();
        INSTANCE.secp256k1_keypair_create(CTX, kp, sk32);

        var parity = new int[]{0};
        var xonlyTmp = new Secp256k1XOnlyPub();
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonlyTmp, parity, kp);

        if (parity[0] == 1) {
            var n = Secp256k1CurveParams.CURVE_ORDER;
            var d = new BigInt(1, sk32);
            d = n.subtract(d).mod(n);
            var evenSk32 = to32(d);

            INSTANCE.secp256k1_keypair_create(CTX, kp, evenSk32);
        }

        var internalX32 = new byte[32];
        INSTANCE.secp256k1_keypair_xonly_pub(CTX, xonlyTmp, null, kp);
        INSTANCE.secp256k1_xonly_pubkey_serialize(CTX, internalX32, xonlyTmp);

        var tweak32 = tapTweak32(internalX32, merkleRoot32);

        if (INSTANCE.secp256k1_keypair_xonly_tweak_add(CTX, kp, tweak32) != 1)
            throw new IllegalStateException("Keypair tweak failed");

        var sig64 = new byte[64];
        INSTANCE.secp256k1_schnorrsig_sign32(CTX, sig64, msg32, kp, auxRand32);
        return sig64;
    }

    public static byte[] expandMessageXmd(String hashAlg, int sInBytes, byte[] msg, byte[] dst, int lenInBytes) {
        if (msg == null) msg = new byte[0];
        if (dst == null) dst = new byte[0];

        if (lenInBytes < 0) throw new IllegalArgumentException("lenInBytes < 0");
        if (dst.length > 255) throw new IllegalArgumentException("DST too long (must be <= 255 bytes)");

        var md = newDigest(hashAlg);
        var bInBytes = digestLength(md);
        if (bInBytes <= 0) throw new IllegalStateException("Cannot determine digest length for " + hashAlg);

        var ell = (lenInBytes + bInBytes - 1) / bInBytes;

        if (ell > 255) throw new IllegalArgumentException("ell > 255");
        if (lenInBytes > 65535) throw new IllegalArgumentException("lenInBytes > 65535");
        if (lenInBytes > 255 * bInBytes) throw new IllegalArgumentException("lenInBytes > 255 * bInBytes");

        if (lenInBytes == 0) return new byte[0];

        var dstPrime = concat(dst, i2osp(dst.length, 1));
        var zPad = new byte[sInBytes];
        var lIBStr = i2osp(lenInBytes, 2);
        var msgPrime = concat(zPad, msg, lIBStr, i2osp(0, 1), dstPrime);
        var b0 = hash(hashAlg, msgPrime);
        var bPrev = hash(hashAlg, concat(b0, i2osp(1, 1), dstPrime));

        var uniform = new byte[ell * bInBytes];
        System.arraycopy(bPrev, 0, uniform, 0, bInBytes);

        for (var i = 2; i <= ell; i++) {
            var x = strxor(b0, bPrev);
            var bi = hash(hashAlg, concat(x, i2osp(i, 1), dstPrime));
            System.arraycopy(bi, 0, uniform, (i - 1) * bInBytes, bInBytes);
            bPrev = bi;
        }

        return Arrays.copyOfRange(uniform, 0, lenInBytes);
    }

    public static byte[] taprootSign(byte[] msg32, byte[] sk32, byte[] merkleRoot32) {
        return taprootSign(msg32, sk32, merkleRoot32, new byte[32]);
    }

    public static boolean taprootVerify(byte[] msg32, byte[] sig64, byte[] xonly32, byte[] merkleRoot32) {
        var tweakedXonly = taprootTweakedXonly(xonly32, merkleRoot32);

        var pub = new Secp256k1XOnlyPub();
        if (INSTANCE.secp256k1_xonly_pubkey_parse(CTX, pub, tweakedXonly) != 1)
            return false;

        return INSTANCE.secp256k1_schnorrsig_verify(
                CTX, sig64, msg32, new NativeLong(msg32.length), pub) == 1;
    }

    private static byte[] hash(String alg, byte[] input) {
        var md = newDigest(alg);
        md.update(input);
        return md.digest();
    }

    private static MessageDigest newDigest(String alg) {
        try {
            return MessageDigest.getInstance(alg);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("Unsupported hash algorithm: " + alg, e);
        }
    }

    private static int digestLength(MessageDigest md) {
        var len = md.getDigestLength();
        if (len > 0) return len;

        return md.digest(new byte[0]).length;
    }

    private static byte[] i2osp(int value, int length) {
        if (length <= 0) throw new IllegalArgumentException("length <= 0");

        var max = 1;
        for (var i = 0; i < length; i++) max *= 256;
        if (value < 0 || value >= max) throw new IllegalArgumentException("value does not fit in " + length + " bytes");

        var out = new byte[length];
        var v = value;
        for (var i = length - 1; i >= 0; i--) {
            out[i] = (byte) (v & 0xFF);
            v >>>= 8;
        }
        return out;
    }

    private static byte[] strxor(byte[] a, byte[] b) {
        if (a.length != b.length) throw new IllegalArgumentException("strxor requires equal lengths");
        var out = new byte[a.length];
        for (var i = 0; i < a.length; i++) out[i] = (byte) (a[i] ^ b[i]);
        return out;
    }

}