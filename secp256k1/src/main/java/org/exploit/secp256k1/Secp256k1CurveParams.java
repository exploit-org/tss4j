package org.exploit.secp256k1;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.jna.LibSecp256k1;
import org.exploit.secp256k1.jna.Secp256k1Context;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.curve.ec.WeierstrassCurveParams;

import java.util.Arrays;

import static org.exploit.secp256k1.Secp256k1PointOps.*;
import static org.exploit.secp256k1.jna.LibSecp256k1.INSTANCE;
import static org.exploit.secp256k1.jna.LibSecp256k1.SECP256K1_EC_COMPRESSED;

public class Secp256k1CurveParams implements WeierstrassCurveParams<Secp256k1PointOps> {
    public static final BigInt CURVE_ORDER = new BigInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
    public static final BigInt FIELD_P = new BigInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16);

    @Override
    public Secp256k1PointOps getG() {
        return Secp256k1PointOps.baseMul(BigInt.ONE);
    }

    @Override
    public BigInt getCurveOrder() {
        return CURVE_ORDER;
    }

    @Override
    public Secp256k1PointOps getInfinity() {
        return INFINITY;
    }

    @Override
    public Secp256k1PointOps createPoint(BigInt x, BigInt y) {
        var xOdd = x.testBit(0);
        var yBe = y.mod(FIELD_P).toByteArray();
        var enc = new byte[33];

        enc[0] = (byte) (xOdd ? 0x03 : 0x02);
        var srcPos = Math.max(yBe.length - 32, 0);

        System.arraycopy(yBe, srcPos, enc, 33 - (yBe.length - srcPos), yBe.length - srcPos);
        return Secp256k1PointOps.fromBytes(enc);
    }

    @Override
    public Secp256k1PointOps decodePoint(byte[] bytes) {
        if (bytes == null)
            throw new IllegalArgumentException("Input is null");

        if ((bytes.length == 33 && Arrays.equals(bytes, COMPRESSED_INFINITY)) || (bytes.length == 65 && Arrays.equals(bytes, UNCOMPRESSED_INFINITY))) {
            return INFINITY;
        }

        if (bytes.length != 33 && bytes.length != 65)
            throw new IllegalArgumentException("Unexpected SEC1 length: " + bytes.length);

        var pubkey64 = new byte[64];
        var ok = LibSecp256k1.INSTANCE.secp256k1_ec_pubkey_parse(Secp256k1Context.CTX, pubkey64, bytes, bytes.length);

        if (ok == 0)
            throw new IllegalArgumentException("Invalid secp256k1 point encoding");

        var compressed = (bytes.length == 33) ? bytes.clone() : serialize(pubkey64, true);

        return new Secp256k1PointOps(compressed);
    }

    @Override
    public Secp256k1PointOps getGeneratorH() {
        return LibSecp256k1.GENERATOR_H;
    }

    @Override
    public int findRecId(BigInt r, BigInt s, byte[] msgHash32, PointOps<Secp256k1PointOps> expectedPk) {
        var sig64 = new byte[64];
        toFixed32(r, sig64, 0);
        toFixed32(s, sig64, 32);

        var expected33 = expectedPk.encode(true);

        var ctx = INSTANCE.secp256k1_context_create(LibSecp256k1.SECP256K1_CONTEXT_VERIFY);

        try {
            var recSig = new byte[65];
            var pubkey = new byte[65];

            for (var recId = 0; recId < 4; recId++) {
                if (INSTANCE.secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, recSig, sig64, recId) == 0)
                    continue;

                if (INSTANCE.secp256k1_ecdsa_recover(ctx, pubkey, recSig, msgHash32) == 0)
                    continue;

                var out33 = new byte[33];
                long[] outLen = {33};

                if (INSTANCE.secp256k1_ec_pubkey_serialize(ctx, out33, outLen, pubkey, SECP256K1_EC_COMPRESSED) == 0)
                    continue;

                if (Arrays.equals(out33, expected33))
                    return recId;
            }

            return -1;
        } finally {
            INSTANCE.secp256k1_context_destroy(ctx);
        }
    }

    private static void toFixed32(BigInt v, byte[] out, int off) {
        var be = v.mod(BigInt.ONE.shiftLeft(256)).toByteArray();
        var srcPos = Math.max(be.length - 32, 0);
        var len = be.length - srcPos;

        Arrays.fill(out, off, off + 32, (byte) 0);
        System.arraycopy(be, srcPos, out, off + 32 - len, len);
    }
}