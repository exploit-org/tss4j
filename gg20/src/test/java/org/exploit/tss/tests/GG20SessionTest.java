package org.exploit.tss.tests;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.sodium.SecretBox;
import org.exploit.tss.TSS;
import org.exploit.tss.ecdsa.GG20Client;
import org.exploit.tss.ecdsa.commitment.GammaCommitment;
import org.exploit.tss.ecdsa.constant.GG20.ComputationType;
import org.exploit.tss.ecdsa.context.GG20Context;
import org.exploit.tss.ecdsa.context.crypto.CryptoContext;
import org.exploit.tss.ecdsa.context.init.InitContext;
import org.exploit.tss.ecdsa.context.mta.MtAContext;
import org.exploit.tss.ecdsa.context.signature.SignatureContext;
import org.exploit.tss.ecdsa.generator.GG20CommitmentGenerator;
import org.exploit.tss.key.RawKeyPair;
import org.exploit.tss.shamir.ECShamirKeySplitter;
import org.exploit.tss.shamir.model.ECKeyShare;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class GG20SessionTest {
    private static final byte[] MEMORY_ENCRYPT_KEY = new byte[32];

    static {
        ZKRandom.getRandom().nextBytes(MEMORY_ENCRYPT_KEY);
    }

    private static final String SESSION_ID = "test";

    private byte[] message;
    private Secp256k1CurveParams curveParams;
    private RawKeyPair keyPair;

    private final List<Integer> participants = List.of(1, 2, 3, 4);
    private final Map<Integer, GG20Client<Secp256k1PointOps>> clients = new HashMap<>();

    @BeforeEach
    public void init() {
        TSS.loadLibraries();

        curveParams = new Secp256k1CurveParams();
        this.message = Hash.sha256("Hello, world!".getBytes());
        this.keyPair = Secp256k1.generateKeyPair();

        var threshold = 2;
        var total = 4;

        var splitter = new ECShamirKeySplitter<>(
            curveParams.getCurveOrder(),
            curveParams.getG(),
            threshold, total
        );

        var privateKey = new BigInt(1, keyPair.getSecretKey());
        var shares = splitter.splitKey(privateKey).shares();

        assertEquals(splitter.recoverKey(shares), privateKey);

        for (var share : shares) {
            var context = createContext(share);

            var h = curveParams.getGeneratorH();
            var commitmentGenerator = new GG20CommitmentGenerator<>(
                    curveParams.getCurveOrder(),
                    curveParams.getG(), h
            );

            var client = new GG20Client<>(SESSION_ID, context, commitmentGenerator);

            var start = System.currentTimeMillis();
            client.init();
            var end = System.currentTimeMillis();
            System.out.println("Client " + share.index() + " initialized in " + (end - start) + "ms");

            clients.put(share.index(), client);
        }
    }

    @Test
    public void assertValidSignature() {
        var coordinator = clients.get(participants.get(0));

        var start = System.currentTimeMillis();
        broadcastGammaPederson();
        var end = System.currentTimeMillis();
        System.out.println("Broadcasted gamma commitments in " + (end - start) + "ms");

        for (var idx : participants) {
            var startMta = System.currentTimeMillis();
            doMta(idx);
            var endMta = System.currentTimeMillis();
            System.out.println("MTA for client " + idx + " completed in " + (endMta - startMta) + "ms");
        }

        var startCollect = System.currentTimeMillis();
        collectOfflinePhase();
        var endCollect = System.currentTimeMillis();
        System.out.println("Collected offline phase in " + (endCollect - startCollect) + "ms");
        var startSignature = System.currentTimeMillis();
        collectPartialS(coordinator);
        var endSignature = System.currentTimeMillis();
        System.out.println("Collected partial S in " + (endSignature - startSignature) + "ms");

        var signature = coordinator.aggregator().calculateSignature().encode();
        assertTrue(Secp256k1.verifyRecoverable(message, signature, keyPair.getPublicKey()));
    }

    private void collectPartialS(GG20Client<Secp256k1PointOps> coordinator) {
        for (var participant : participants) {
            var clientI = clients.get(participant);
            var partialS = clientI.signature().computePartialS();

            coordinator.context().aggregator().storePartialS(participant, partialS);
        }
    }

    private void broadcastGammaPederson() {
        for (var i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var clientJ = clients.get(participants.get(j));
                var commitment = clientJ.context().crypto().ephemeral().commitment();
                var r_i = clientJ.context().crypto().ephemeral().r_i();

                clientI.context().integrity().storeGammaCommitment(participants.get(j), new GammaCommitment<>(commitment, r_i));
            }
        }
    }

    private void collectOfflinePhase() {
        for (int i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var peerId = participants.get(j);
                var clientJ = clients.get(peerId);
                var gamma = clientJ.context().crypto().ephemeral().Gamma_i();
                var deltaShare = clientJ.signature().computeDeltaShare();

                var lambdaCommitment = clientJ.integrity().computeLambdaI();
                var sigmaCommitment = clientJ.integrity().computeSigmaCommitment();

                clientI.signature().storeGamma(peerId, gamma);
                clientI.integrity().storeLambdaCommitment(peerId, lambdaCommitment);
                clientI.integrity().storeSigmaCommitment(peerId, sigmaCommitment);
                clientI.context().signature().storeDeltaShare(peerId, deltaShare);
            }
        }
    }

    private void doMta(int idx) {
        var initiator = clients.get(idx);
        var initiatorMessage = initiator.context().mta().initiator().message();

        var zkSetup = initiator.context().crypto().zkSetup();
        var publicKey = initiator.context().crypto().paillier()
                .publicKey();

        var respondents = clients.values().stream()
                .filter(c -> c.context().crypto().idx() != idx)
                .toList();

        for (var respondent : respondents) {
            var peerId = respondent.context().crypto().idx();

            var start = System.currentTimeMillis();
            var alpha = respondent.mta().asRespondent().compute(ComputationType.GAMMA, idx,
                    publicKey, zkSetup, initiatorMessage);
            var end = System.currentTimeMillis();
            System.out.println("Respondent " + peerId + " computed alpha in " + (end - start) + "ms");

            var startMu = System.currentTimeMillis();
            var mu = respondent.mta().asRespondent().compute(ComputationType.LAGRANGE, idx,
                    publicKey, zkSetup, initiatorMessage);
            var endMu = System.currentTimeMillis();
            System.out.println("Respondent " + peerId + " computed mu in " + (endMu - startMu) + "ms");

            var startStore = System.currentTimeMillis();
            initiator.mta().asInitiator().store(ComputationType.GAMMA, peerId, alpha);
            initiator.mta().asInitiator().store(ComputationType.LAGRANGE, peerId, mu);
            var endStore = System.currentTimeMillis();
            System.out.println("Initiator " + idx + " stored alpha and mu in " + (endStore - startStore) + "ms");
        }
    }

    private GG20Context<Secp256k1PointOps> createContext(ECKeyShare<Secp256k1PointOps> keyShare) {
        var initContext = InitContext.inMemoryBuilder()
                .additionalContext(new byte[0])
                .message(message)
                .build();

        var cryptoContext = CryptoContext.inMemoryBuilder(Secp256k1PointOps.class)
                .idx(keyShare.index())
                .ski(SecretBox.of(keyShare.share().toByteArray(), MEMORY_ENCRYPT_KEY, false))
                .participants(participants)
                .memKey(MEMORY_ENCRYPT_KEY::clone)
                .publicKey(curveParams.decodePoint(keyPair.getPublicKey()))
                .curve(curveParams)
                .build();

        return GG20Context.newBuilder(Secp256k1PointOps.class)
                .init(initContext)
                .mta(MtAContext.inMemory())
                .crypto(cryptoContext)
                .signature(SignatureContext.inMemory())
                .build();
    }
}
