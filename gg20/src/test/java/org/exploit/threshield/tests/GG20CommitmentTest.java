package org.exploit.threshield.tests;

import com.sun.jna.NativeLibrary;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.threshield.ecdsa.generator.GG20CommitmentGenerator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class GG20CommitmentTest {
    private BigInt q;
    private Secp256k1PointOps g;
    private GG20CommitmentGenerator<Secp256k1PointOps> generator;

    @BeforeEach
    public void setUp() {
        NativeLibrary.addSearchPath("secp256k1", "/opt/homebrew/Cellar/secp256k1/0.6.0/lib");
        NativeLibrary.addSearchPath("gmp", "/opt/homebrew/Cellar/gmp/6.3.0/lib");

        var ecSpec = new Secp256k1CurveParams();

        q = ecSpec.getCurveOrder();
        g = ecSpec.getG();

        var h = ecSpec.getGeneratorH();

        generator = new GG20CommitmentGenerator<>(q, g, h);
    }

    @Test
    public void testSuccessfulVerification() {
        var result = generator.createGammaCommitment();
        var isValid = generator.verifyGammaCommitment(result.commitment(), result.Gamma_i(), result.r_i());

        assertTrue(isValid);
    }

    @Test
    public void testVerificationWithIncorrectGamma() {
        var result = generator.createGammaCommitment();
        var wrongGamma = result.gamma_i().add(BigInt.ONE).mod(q);
        var wrongGamma_i = g.mul(wrongGamma).normalize();
        var isValid = generator.verifyGammaCommitment(result.commitment(), wrongGamma_i, result.r_i());

        assertFalse(isValid);
    }

    @Test
    public void testVerificationWithIncorrectR() {
        var result = generator.createGammaCommitment();
        var wrongR = result.r_i().add(BigInt.ONE).mod(q);
        var isValid = generator.verifyGammaCommitment(result.commitment(), result.Gamma_i(), wrongR);

        assertFalse(isValid);
    }
}