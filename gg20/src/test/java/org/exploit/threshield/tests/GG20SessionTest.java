package org.exploit.threshield.tests;

import org.bouncycastle.asn1.sec.SECNamedCurves;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.threshield.curve.jce.ECCurveParams;
import org.exploit.threshield.curve.jce.ECPointOps;
import org.exploit.threshield.ecdsa.GG20Client;
import org.exploit.threshield.ecdsa.commitment.GammaCommitment;
import org.exploit.threshield.ecdsa.constant.GG20;
import org.exploit.threshield.ecdsa.constant.GG20.ComputationType;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.threshield.ecdsa.context.crypto.CryptoContext;
import org.exploit.threshield.ecdsa.context.init.InitContext;
import org.exploit.threshield.ecdsa.context.mta.MtAContext;
import org.exploit.threshield.ecdsa.context.signature.SignatureContext;
import org.exploit.zktrust.share.ECShamirKeySplitter;
import org.exploit.zktrust.share.model.ECKeyShare;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class GG20SessionTest {
    private static final String SESSION_ID = "test";

    private byte[] message;
    private Secp256k1KeyPair keyPair;

    private final List<Integer> participants = List.of(1, 2, 3, 4);
    private final Map<Integer, GG20Client> clients = new HashMap<>();

    @BeforeEach
    public void init() {
        this.message = Hash.sha256("Hello, world!".getBytes());
        this.keyPair = Secp256k1Provider.getInstance().generateKeyPair();

        var threshold = 2;
        var total = 4;

        var splitter = new ECShamirKeySplitter(
            Secp256k1Provider.getCurveOrder(),
            Secp256k1Provider.CURVE.getG(),
            threshold, total
        );

        var shares = splitter.splitKey(keyPair.privateKey().toBigInt()).shares();
        assertEquals(splitter.recoverKey(shares), keyPair.privateKey().toBigInt());

        for (var share : shares) {
            var context = createContext(share);
            var client = new GG20Client(SESSION_ID, context, GG20.CommitmentGenerator.SECP256k1);
            client.init();

            clients.put(share.index(), client);
        }
    }

    @Test
    public void assertValidSignature() {
        var coordinator = clients.get(participants.get(0));

        broadcastGammaPederson();

        for (var idx : participants) {
            doMta(idx);
        }

        collectOfflinePhase();
        collectPartialS(coordinator);

        var signature = coordinator.aggregator().calculateSignature();
        assertTrue(Secp256k1Provider.getInstance().verify(message, signature, keyPair.publicKey()));
    }

    private void collectPartialS(GG20Client coordinator) {
        for (var participant : participants) {
            var clientI = clients.get(participant);
            var partialS = clientI.signature().computePartialS();

            coordinator.context().aggregator().storePartialS(participant, partialS);
        }
    }

    private void broadcastGammaPederson() {
        for (var i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var clientJ = clients.get(participants.get(j));
                var commitment = clientJ.context().crypto().ephemeral().commitment();
                var r_i = clientJ.context().crypto().ephemeral().r_i();

                clientI.context().integrity().storeGammaCommitment(participants.get(j), new GammaCommitment(commitment, r_i));
            }
        }
    }

    private void collectOfflinePhase() {
        for (int i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var peerId = participants.get(j);
                var clientJ = clients.get(peerId);
                var gamma = clientJ.context().crypto().ephemeral().Gamma_i();
                var deltaShare = clientJ.signature().computeDeltaShare();

                var lambdaCommitment = clientJ.integrity().computeLambdaI();
                var sigmaCommitment = clientJ.integrity().computeSigmaCommitment();

                clientI.signature().storeGamma(peerId, gamma);
                clientI.integrity().storeLambdaCommitment(peerId, lambdaCommitment);
                clientI.integrity().storeSigmaCommitment(peerId, sigmaCommitment);
                clientI.context().signature().storeDeltaShare(peerId, deltaShare);
            }
        }
    }

    private void doMta(int idx) {
        var initiator = clients.get(idx);
        var initiatorMessage = initiator.context().mta().initiator().message();

        var zkSetup = initiator.context().crypto().zkSetup();
        var publicKey = initiator.context().crypto().paillier()
                .publicKey();

        var respondents = clients.values().stream()
                .filter(c -> c.context().crypto().idx() != idx)
                .toList();

        for (var respondent : respondents) {
            var peerId = respondent.context().crypto().idx();
            var alpha = respondent.mta().asRespondent().compute(ComputationType.GAMMA, idx,
                    publicKey, zkSetup, initiatorMessage);

            var mu = respondent.mta().asRespondent().compute(ComputationType.LAGRANGE, idx,
                    publicKey, zkSetup, initiatorMessage);

            initiator.mta().asInitiator().store(ComputationType.GAMMA, peerId, alpha);
            initiator.mta().asInitiator().store(ComputationType.LAGRANGE, peerId, mu);
        }
    }

    private GG20Context createContext(ECKeyShare keyShare) {
        var initContext = InitContext.inMemoryBuilder()
                .additionalContext(new byte[0])
                .message(message)
                .build();

        var cryptoContext = CryptoContext.inMemoryBuilder()
                .curve(new ECCurveParams(SECNamedCurves.getByName("secp256k1")))
                .idx(keyShare.index())
                .ski(keyShare.share())
                .participants(participants)
                .publicKey(new ECPointOps(keyPair.publicKey().point()))
                .build();

        return GG20Context.newBuilder()
                .init(initContext)
                .mta(MtAContext.inMemory())
                .crypto(cryptoContext)
                .signature(SignatureContext.inMemory())
                .build();
    }
}
