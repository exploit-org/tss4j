package org.exploit.threshield.ecdsa.generator;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.math.ec.ECPoint;
import org.exploit.crypto.Hash;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersenProof;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitment;
import org.exploit.zktrust.commitment.PedersenCommitment;
import org.exploit.zktrust.commitment.model.CommitmentResult;
import org.exploit.zktrust.util.ZKRandom;

import java.math.BigInteger;

public class GG20CommitmentGenerator {
    private final BigInteger q;
    private final ECPoint g;
    private final PedersenCommitment pedersen;
    private final ECPoint h;

    public GG20CommitmentGenerator(BigInteger q, ECPoint g, ECPoint h) {
        this.q = q;
        this.g = g;
        this.pedersen = new PedersenCommitment(g, h, q);
        this.h = h;
    }

    public CommitmentResult createGammaCommitment() {
        var k_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);

        var gamma_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var Gamma_i = g.multiply(gamma_i).normalize();

        var r_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var xCoord = Gamma_i.getAffineXCoord().toBigInteger();
        var C_i = pedersen.commit(xCoord, r_i);

        return new CommitmentResult(C_i, Gamma_i, r_i, k_i, gamma_i);
    }

    public boolean verifyGammaCommitment(ECPoint C_i, ECPoint Gamma_i, BigInteger r_i) {
        var xCoord = Gamma_i.getAffineXCoord().toBigInteger();
        return pedersen.verify(C_i, xCoord, r_i);
    }

    public ChaumPedersonCommitment createChaumCommitment(BigInteger value) {
        var t = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var T = g.multiply(value).add(h.multiply(t)).normalize();

        var proof = generateProof(g, h, T, value, t, q);
        return new ChaumPedersonCommitment(T, t, proof);
    }

    public boolean verifyChaumCommitment(ChaumPedersonCommitment commitment) {
        var T = commitment.T();
        var proof = commitment.proof();
        var c = computeChallenge(g, h, T, proof.getA(), q);

        var left = g.multiply(proof.getR()).add(h.multiply(proof.getS())).normalize();
        var right = proof.getA().add(T.multiply(c)).normalize();

        return left.equals(right);
    }

    private static ChaumPedersenProof generateProof(ECPoint g, ECPoint h, ECPoint T, BigInteger sigma, BigInteger t, BigInteger q) {
        var a = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var b = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);

        var A = g.multiply(a).add(h.multiply(b)).normalize();
        var c = computeChallenge(g, h, T, A, q);

        var rResponse = a.add(c.multiply(sigma)).mod(q);
        var sResponse = b.add(c.multiply(t)).mod(q);

        return new ChaumPedersenProof(A, rResponse, sResponse);
    }

    private static BigInteger computeChallenge(ECPoint g, ECPoint h, ECPoint T, ECPoint A, BigInteger q) {
        var bytes = Bytes.from(g.getEncoded(true), h.getEncoded(true), T.getEncoded(true), A.getEncoded(true)).array();
        var hash = Hash.sha256(bytes);
        return new BigInteger(1, hash).mod(q);
    }
}