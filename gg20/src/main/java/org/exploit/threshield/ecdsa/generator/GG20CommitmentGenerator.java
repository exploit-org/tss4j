package org.exploit.threshield.ecdsa.generator;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.threshield.commitment.PedersenCommitment;
import org.exploit.threshield.curve.ec.WeierstrassPointOps;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersenProof;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitment;
import org.exploit.threshield.util.ZKRandom;

public class GG20CommitmentGenerator<P extends WeierstrassPointOps<P>> {
    private final BigInt q;
    private final WeierstrassPointOps<P> g;
    private final WeierstrassPointOps<P> h;
    private final PedersenCommitment<P> pedersen;

    public GG20CommitmentGenerator(BigInt q, WeierstrassPointOps<P> g, WeierstrassPointOps<P> h) {
        this.q = q;
        this.g = g;
        this.h = h;
        this.pedersen = new PedersenCommitment<>(g, h, q);
    }

    public CommitmentResult<P> createGammaCommitment() {
        var k_i = new BigInt(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var gamma_i = new BigInt(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var Gamma_i = g.mul(gamma_i).normalize();

        var r_i = new BigInt(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var C_i = pedersen.commit(Gamma_i.getAffineX(), r_i);

        return new CommitmentResult<>((WeierstrassPointOps<P>) C_i, Gamma_i, r_i, k_i, gamma_i);
    }

    public boolean verifyGammaCommitment(WeierstrassPointOps<P> C_i, WeierstrassPointOps<P> Gamma_i, BigInt r_i) {
        return pedersen.verify(C_i, Gamma_i.getAffineX(), r_i);
    }

    public ChaumPedersonCommitment<P> createChaumCommitment(BigInt value) {
        var rnd = ZKRandom.getRandom();

        var t = new BigInt(q.bitLength(), rnd).mod(q);
        var T = g.mul(value).add(h.mul(t)).normalize();

        var proof = generateProof(value, t, T);
        return new ChaumPedersonCommitment<>(T, t, proof);
    }

    public boolean verifyChaumCommitment(ChaumPedersonCommitment<P> commitment) {
        var T = commitment.T();
        var proof = commitment.proof();
        var c = computeChallenge(T, proof.getA());

        var left = g.mul(proof.getR()).add(h.mul(proof.getS())).normalize();
        var right = proof.getA().add(T.mul(c)).normalize();

        return left.equals(right);
    }

    private ChaumPedersenProof<P> generateProof(BigInt sigma, BigInt t, WeierstrassPointOps<P> T) {
        var rnd = ZKRandom.getRandom();

        var a = new BigInt(q.bitLength(), rnd).mod(q);
        var b = new BigInt(q.bitLength(), rnd).mod(q);

        var A = g.mul(a).add(h.mul(b)).normalize();
        var c = computeChallenge(T, A);

        var rResp = a.add(c.multiply(sigma)).mod(q);
        var sResp = b.add(c.multiply(t)).mod(q);

        return new ChaumPedersenProof<>(A, rResp, sResp);
    }

    private BigInt computeChallenge(WeierstrassPointOps<P> T, WeierstrassPointOps<P> A) {
        var bytes = Bytes.from(g.encode(true), h.encode(true), T.encode(true), A.encode(true)).array();
        return new BigInt(1, Hash.sha256(bytes)).mod(q);
    }
}