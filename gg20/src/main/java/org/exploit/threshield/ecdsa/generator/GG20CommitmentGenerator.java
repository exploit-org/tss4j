package org.exploit.threshield.ecdsa.generator;

import at.favre.lib.bytes.Bytes;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.FixedPointCombMultiplier;
import org.bouncycastle.math.ec.FixedPointUtil;
import org.exploit.crypto.Hash;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersenProof;
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitment;
import org.exploit.zktrust.commitment.PedersenCommitment;
import org.exploit.zktrust.commitment.model.CommitmentResult;
import org.exploit.zktrust.util.ZKRandom;

import java.math.BigInteger;

public class GG20CommitmentGenerator {
    private final BigInteger q;
    private final ECPoint g;
    private final ECPoint h;
    private final PedersenCommitment pedersen;

    public GG20CommitmentGenerator(BigInteger q, ECPoint g, ECPoint h) {
        this.q = q;
        this.g = g;
        this.h = h;
        this.pedersen = new PedersenCommitment(g, h, q);

        FixedPointUtil.precompute(g);
        FixedPointUtil.precompute(h);
    }

    public CommitmentResult createGammaCommitment() {
        var k_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var gamma_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var Gamma_i = fastMul(g, gamma_i).normalize();

        var r_i = new BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q);
        var C_i = pedersen.commit(Gamma_i.getAffineXCoord().toBigInteger(), r_i);

        return new CommitmentResult(C_i, Gamma_i, r_i, k_i, gamma_i);
    }

    public boolean verifyGammaCommitment(ECPoint C_i, ECPoint Gamma_i, BigInteger r_i) {
        return pedersen.verify(C_i, Gamma_i.getAffineXCoord().toBigInteger(), r_i);
    }

    public ChaumPedersonCommitment createChaumCommitment(BigInteger value) {
        var rnd = ZKRandom.getRandom();

        var t = new BigInteger(q.bitLength(), rnd).mod(q);
        var T = fastMul(g, value).add(fastMul(h, t)).normalize();

        var proof = generateProof(value, t, T);
        return new ChaumPedersonCommitment(T, t, proof);
    }

    public boolean verifyChaumCommitment(ChaumPedersonCommitment commitment) {
        var T = commitment.T();
        var proof = commitment.proof();
        var c = computeChallenge(T, proof.getA());

        var left = fastMul(g, proof.getR()).add(fastMul(h, proof.getS())).normalize();
        var right = proof.getA().add(fastMul(T, c)).normalize();

        return left.equals(right);
    }

    private ChaumPedersenProof generateProof(BigInteger sigma, BigInteger t, ECPoint T) {
        var rnd = ZKRandom.getRandom();

        var a = new BigInteger(q.bitLength(), rnd).mod(q);
        var b = new BigInteger(q.bitLength(), rnd).mod(q);

        var A = fastMul(g, a).add(fastMul(h, b)).normalize();
        var c = computeChallenge(T, A);

        var rResp = a.add(c.multiply(sigma)).mod(q);
        var sResp = b.add(c.multiply(t)).mod(q);

        return new ChaumPedersenProof(A, rResp, sResp);
    }

    private BigInteger computeChallenge(ECPoint T, ECPoint A) {
        var bytes = Bytes.from(g.getEncoded(true), h.getEncoded(true), T.getEncoded(true), A.getEncoded(true)).array();
        return new BigInteger(1, Hash.sha256(bytes)).mod(q);
    }

    private static ECPoint fastMul(ECPoint base, BigInteger k) {
        return new FixedPointCombMultiplier().multiply(base, k);
    }
}