package org.exploit.threshield.ecdsa.mta;

import lombok.AllArgsConstructor;
import org.exploit.threshield.ecdsa.constant.GG20;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.zktrust.cipher.key.PaillierPublicKey;
import org.exploit.zktrust.mta.MtAProtocol;
import org.exploit.zktrust.mta.model.MtAInitiatorMessage;
import org.exploit.zktrust.mta.model.MtAResult;
import org.exploit.zktrust.proof.pallier.model.ZKSetup;

import java.math.BigInteger;

@AllArgsConstructor
public class MtARespondentProtocolRunner {
    private final MtAProtocol mta;
    private final GG20Context context;

    public MtAResult compute(GG20.ComputationType type, int initiatorId, PaillierPublicKey initiatorPublicKey, ZKSetup zk, MtAInitiatorMessage message) {
        var nonce = context.init().additionalContext();

        if (!mta.verifyInitiatorProof(message, initiatorPublicKey, zk, nonce))
            throw new IllegalArgumentException("Invalid initiator %s proof for %s computation".formatted(initiatorPublicKey, type));

        return switch (type) {
            case GAMMA -> computeWithGamma(initiatorId, initiatorPublicKey, message.cA());
            case LAGRANGE -> computeWithLagrangeShare(initiatorId, initiatorPublicKey, zk, message.cA());
        };
    }

    private MtAResult computeWithGamma(int initiatorId, PaillierPublicKey publicKey, BigInteger cA) {
        var gamma = context.crypto().ephemeral().gamma_i();
        var result = mta.computeCjWithY(publicKey, cA, gamma);
        var beta = result.y().negate().mod(context.crypto().curve().getCurveOrder());

        context.mta().respondent().storeBeta(initiatorId, beta);
        return result;
    }

    private MtAResult computeWithLagrangeShare(int initiatorId, PaillierPublicKey publicKey, ZKSetup zk, BigInteger cA) {
        var lagrangeShare = context.crypto().lagrangeShare();
        var nonce = context.init().additionalContext();

        var result = mta.computeCjWithY(publicKey, cA, lagrangeShare, zk, nonce);
        var nu = result.y().negate().mod(context.crypto().curve().getCurveOrder());

        context.mta().respondent().storeNu(initiatorId, nu);

        return result;
    }
}
