package org.exploit.threshield.ecdsa.aggregator;

import lombok.AllArgsConstructor;
import org.exploit.crypto.signature.ECDSASignature;
import org.exploit.threshield.curve.ec.WeierstrassPointOps;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.threshield.ecdsa.signature.PartialSignatureCalculator;

@AllArgsConstructor
public class SignaturePartAggregator<P extends WeierstrassPointOps<P>> {
    private final GG20Context<P> context;
    private final PartialSignatureCalculator<P> calculator;

    public ECDSASignature calculateSignature() {
        var r = calculator.computeSignatureR();
        var s = context.aggregator().sumS(context.crypto().curve().getCurveOrder());
        var halfCurveOrder = context.crypto().curve().getCurveOrder().shiftRight(1);

        if (s.compareTo(halfCurveOrder) > 0) {
            s = context.crypto().curve().getCurveOrder().subtract(s);
        }

        var recId = context.crypto().curve().findRecId(r,s, context.init().message(), context.crypto().publicKey());

        if (recId == -1)
            throw new IllegalStateException("Could not construct a recoverable key. This should never happen.");

        return new ECDSASignature(r.toJavaInt(), s.toJavaInt(), (byte) recId);
    }
}
