package org.exploit.threshield.ecdsa.aggregator;

import lombok.AllArgsConstructor;
import org.bouncycastle.asn1.x9.X9IntegerConverter;
import org.bouncycastle.math.ec.ECAlgorithms;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.exploit.crypto.signature.ECDSASignature;
import org.exploit.threshield.curve.jce.ECCurveParams;
import org.exploit.threshield.curve.jce.ECPointOps;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.threshield.ecdsa.signature.PartialSignatureCalculator;

import java.math.BigInteger;
import java.util.Arrays;

@AllArgsConstructor
public class SignaturePartAggregator {
    private final GG20Context context;
    private final PartialSignatureCalculator calculator;

    public ECDSASignature calculateSignature() {
        var r = calculator.computeSignatureR();
        var s = context.aggregator().sumS(context.crypto().curve().getCurveOrder());
        var halfCurveOrder = context.crypto().curve().getCurveOrder().shiftRight(1);

        if (s.compareTo(halfCurveOrder) > 0) {
            s = context.crypto().curve().getCurveOrder().subtract(s);
        }

        var recId = -1;

        for (var i = 0; i < 4; i++) {
            var k = recoverFromSignature(i, r, s, context.init().message());

            if (k != null && k.equals(context.crypto().publicKey())) {
                recId = i;
                break;
            }
        }

        if (recId == -1)
            throw new IllegalStateException("Could not construct a recoverable key. This should never happen.");

        return new ECDSASignature(r, s, (byte) recId);
    }

    private ECPointOps recoverFromSignature(int recId, BigInteger r, BigInteger s, byte[] dataHash) {
        var x9 = ((ECCurveParams) context.crypto().curve()).getX9ECParameters();
        var n = context.crypto().curve().getCurveOrder();
        var i = BigInteger.valueOf((long) recId / 2);
        var x = r.add(i.multiply(n));

        var prime = x9.getCurve().getField().getCharacteristic();

        if (x.compareTo(prime) >= 0) {
            return null;
        }

        var rPoint = decompressKey(x9.getCurve(), x, (recId & 1) == 1);

        if (!rPoint.multiply(n).isInfinity()) {
            return null;
        }

        var e = new BigInteger(1, dataHash);

        var eInv = e.negate().mod(n);
        var rInv = r.modInverse(n);
        var srInv = rInv.multiply(s).mod(n);
        var eInvrInv = rInv.multiply(eInv).mod(n);

        var q = ECAlgorithms.sumOfTwoMultiplies(x9.getG(), eInvrInv, rPoint, srInv);

        if (q.isInfinity()) {
            return null;
        }

        return new ECPointOps(q);
    }

    private static ECPoint decompressKey(ECCurve curve, BigInteger xBN, boolean yBit) {
        var x9 = new X9IntegerConverter();
        var compEnc = x9.integerToBytes(xBN, 1 + x9.getByteLength(curve));
        compEnc[0] = (byte) (yBit ? 0x03 : 0x02);

        return curve.decodePoint(compEnc);
    }
}
