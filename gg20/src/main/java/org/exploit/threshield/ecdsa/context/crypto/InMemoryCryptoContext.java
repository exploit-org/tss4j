package org.exploit.threshield.ecdsa.context.crypto;

import lombok.AllArgsConstructor;
import org.exploit.threshield.curve.jce.ECCurveParams;
import org.exploit.threshield.curve.jce.ECPointOps;
import org.exploit.zktrust.cipher.Paillier;
import org.exploit.zktrust.cipher.key.PaillierKeyPair;
import org.exploit.zktrust.commitment.model.CommitmentResult;
import org.exploit.zktrust.proof.pallier.model.ZKSetup;

import java.math.BigInteger;
import java.util.List;
import java.util.Objects;

@AllArgsConstructor(access = lombok.AccessLevel.PRIVATE)
public class InMemoryCryptoContext implements CryptoContext {
    private final int idx;
    private final BigInteger ski;
    private final PaillierKeyPair paillier;
    private final ECCurveParams curve;
    private final List<Integer> participants;
    private final ECPointOps publicKey;

    private CommitmentResult commitment;
    private ZKSetup zkSetup;

    @Override
    public void setCommitment(CommitmentResult commitment) {
        Objects.requireNonNull(commitment, "Commitment cannot be null");
        this.commitment = commitment;
    }

    @Override
    public boolean isInitialized() {
        return commitment != null;
    }

    @Override
    public int idx() {
        return idx;
    }

    @Override
    public BigInteger ski() {
        return ski;
    }

    @Override
    public PaillierKeyPair paillier() {
        return paillier;
    }

    @Override
    public ECPointOps publicKey() {
        return publicKey;
    }

    @Override
    public CommitmentResult ephemeral() {
        return commitment;
    }

    @Override
    public ZKSetup zkSetup() {
        return zkSetup;
    }

    @Override
    public ECCurveParams curve() {
        return curve;
    }

    @Override
    public List<Integer> participants() {
        return participants;
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private int idx;
        private PaillierKeyPair paillier;
        private CommitmentResult commitment;
        private ECPointOps publicKey;

        private ZKSetup zkSetup;
        private ECCurveParams curve;
        private BigInteger ski;

        private List<Integer> participants;

        public Builder idx(int idx) {
            this.idx = idx;
            return this;
        }

        public Builder paillier(PaillierKeyPair paillier) {
            this.paillier = paillier;
            return this;
        }

        public Builder ski(BigInteger ski) {
            this.ski = ski;
            return this;
        }

        public Builder publicKey(ECPointOps publicKey) {
            this.publicKey = publicKey;
            return this;
        }

        public Builder participants(List<Integer> participants) {
            this.participants = participants;
            return this;
        }

        public Builder commitment(CommitmentResult commitment) {
            this.commitment = commitment;
            return this;
        }

        public Builder zkSetup(ZKSetup zkSetup) {
            this.zkSetup = zkSetup;
            return this;
        }

        public Builder curve(ECCurveParams curve) {
            this.curve = curve;
            return this;
        }

        public InMemoryCryptoContext build() {
            if (paillier == null)
                paillier = Paillier.generateKeyPair(3072);

            if (zkSetup == null)
                zkSetup = ZKSetup.generate(2048);

            Objects.requireNonNull(zkSetup, "ZKSetup cannot be null");
            Objects.requireNonNull(curve, "Curve cannot be null");
            Objects.requireNonNull(ski, "Secret key cannot be null");
            Objects.requireNonNull(publicKey, "Public key point cannot be null");

            if (participants == null || participants.isEmpty()) {
                throw new IllegalArgumentException("Participants cannot be null or empty");
            }

            return new InMemoryCryptoContext(idx, ski, paillier, curve, participants, publicKey, commitment, zkSetup);
        }
    }
}
