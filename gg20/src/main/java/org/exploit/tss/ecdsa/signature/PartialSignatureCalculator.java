package org.exploit.tss.ecdsa.signature;

import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.GG20Client;
import org.exploit.tss.ecdsa.context.GG20Context;
import org.exploit.tss.exception.IdentifiableAbortException;

public class PartialSignatureCalculator<P extends WeierstrassPointOps<P>> {
    private final GG20Context<P> context;
    private final GG20Client<P> client;

    public PartialSignatureCalculator(GG20Context<P> context, GG20Client<P> client) {
        this.context = context;
        this.client = client;
    }

    public void storeGamma(int peerId, WeierstrassPointOps<P> gamma) {
        var gammaCommitment = context.integrity().getGammaCommitment(peerId);

        if (gammaCommitment == null) {
            throw new IdentifiableAbortException(peerId, "Gamma commitment not found");
        }

        if (!client.generator().verifyGammaCommitment(gammaCommitment.C_i(), gamma, gammaCommitment.r_i())) {
            throw new IdentifiableAbortException(peerId, "Gamma commitment verification failed");
        }

        context.signature().storeGamma(peerId, gamma);
    }

    public BigInt computeDeltaShare() {
        var commitment = context.crypto().ephemeral();
        var q = context.crypto().curve().getCurveOrder();
        var kG = commitment.k_i().multiplySec(commitment.gamma_i()).mod(q);

        return context.mta().respondent().modSumBeta(context.mta().initiator().modSumAlpha(kG, q), q);
    }

    public BigInt computeSigmaShare() {
        return context.crypto().useLagrangeShare(share -> {
            var commitment = context.crypto().ephemeral();
            var q = context.crypto().curve().getCurveOrder();
            var kW = commitment.k_i().multiplySec(share).mod(q);

            return context.mta().respondent().modSumNu(context.mta().initiator().modSumMu(kW, q), q);
        });
    }

    public BigInt computeSignatureR() {
        var gammaProduct = context.signature().computeGammaProduct(context.crypto().ephemeral().Gamma_i());
        var q = context.crypto().curve().getCurveOrder();
        var deltaInv = context.signature().computeDeltaSum(computeDeltaShare(), q)
                .modInverseSec(q);
        var R = gammaProduct.mul(deltaInv).normalize();

        return R.getAffineX().mod(q);
    }

    public BigInt computePartialS() {
        var q = context.crypto().curve().getCurveOrder();
        var m = new BigInt(1, context.init().message()).mod(q);
        var r = computeSignatureR();

        var ki = context.crypto().ephemeral().k_i();
        var sigmaI = computeSigmaShare();

        return ki.multiplySec(m).add(r.multiplySec(sigmaI)).mod(q);
    }
}
