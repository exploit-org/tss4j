package org.exploit.tss.ecdsa.mta;

import lombok.AllArgsConstructor;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.constant.GG20;
import org.exploit.tss.ecdsa.context.GG20Context;
import org.exploit.tss.mta.MtAProtocol;
import org.exploit.tss.mta.model.MtAResult;

@AllArgsConstructor
public class MtAInitiatorProtocolRunner<P extends WeierstrassPointOps<P>> {
    private final MtAProtocol mta;
    private final GG20Context<P> context;

    void generateInitiatorMessage() {
        var initiatorMessage = mta.generateInitiatorMessage(context.crypto().ephemeral().k_i(),
                context.crypto().zkSetup(), context.init().additionalContext());

        context.mta().initiator().setInitiatorMessage(initiatorMessage);
    }

    public void store(GG20.ComputationType type, int peerId, MtAResult result) {
        var zkSetup = context.crypto().zkSetup();
        var publicKey = context.crypto().paillier().publicKey();
        var cA = context.mta().initiator().message().cA();

        switch (type) {
            case GAMMA -> {
                var decrypted = mta.decryptCj(result.c_j()).mod(context.crypto().curve().getCurveOrder());
                context.mta().initiator().storeAlpha(peerId, decrypted);
            }
            case LAGRANGE -> {
                if (!mta.verifyRespondentProof(result, cA, publicKey, zkSetup, context.init().additionalContext()))
                    throw new SecurityException("Invalid respondent proof for " + peerId);

                var decrypted = mta.decryptCj(result.c_j()).mod(context.crypto().curve().getCurveOrder());
                context.mta().initiator().storeMu(peerId, decrypted);
            }
        }
    }
}
