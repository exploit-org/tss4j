package org.exploit.tss.ecdsa.generator;

import lombok.AllArgsConstructor;
import org.exploit.tss.util.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.commitment.ChaumPedersenProof;
import org.exploit.tss.ecdsa.commitment.ChaumPedersonCommitment;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.ZKRandom;

@AllArgsConstructor
public class ChaumPedersonProofGenerator<P extends WeierstrassPointOps<P>> {
    private final BigInt q;
    private final WeierstrassPointOps<P> g;
    private final WeierstrassPointOps<P> h;

    public boolean verifyChaumCommitment(ChaumPedersonCommitment<P> commitment) {
        var T = commitment.T();
        var proof = commitment.proof();
        var c = computeChallenge(T, proof.getA());

        var left = g.mul(proof.getR()).add(h.mul(proof.getS())).normalize();
        var right = proof.getA().add(T.mul(c)).normalize();

        return left.equals(right);
    }

    public ChaumPedersenProof<P> generateProof(BigInt sigma, BigInt t, WeierstrassPointOps<P> T) {
        var rnd = ZKRandom.getRandom();

        var a = new BigInt(q.bitLength(), rnd).mod(q);
        var b = new BigInt(q.bitLength(), rnd).mod(q);

        var A = g.mul(a).add(h.mul(b)).normalize();
        var c = computeChallenge(T, A);

        var rResp = a.add(c.multiplySec(sigma)).mod(q);
        var sResp = b.add(c.multiplySec(t)).mod(q);

        return new ChaumPedersenProof<>(A, rResp, sResp);
    }

    private BigInt computeChallenge(WeierstrassPointOps<P> T, WeierstrassPointOps<P> A) {
        var bytes = Bytes.encode(g.encode(true), h.encode(true), T.encode(true), A.encode(true));
        return new BigInt(1, Hash.sha256(bytes)).mod(q);
    }
}
