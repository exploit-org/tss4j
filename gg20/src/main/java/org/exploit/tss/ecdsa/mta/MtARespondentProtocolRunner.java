package org.exploit.tss.ecdsa.mta;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.constant.GG20;
import org.exploit.tss.ecdsa.context.GG20Context;
import org.exploit.tss.mta.MtAProtocol;
import org.exploit.tss.mta.model.MtAInitiatorMessage;
import org.exploit.tss.mta.model.MtAResult;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.model.ZKSetup;

@AllArgsConstructor
public class MtARespondentProtocolRunner<P extends WeierstrassPointOps<P>> {
    private final MtAProtocol mta;
    private final GG20Context<P> context;

    public MtAResult compute(GG20.ComputationType type, int initiatorId, PaillierPublicKey initiatorPublicKey, ZKSetup zk, MtAInitiatorMessage message) {
        var nonce = context.init().additionalContext();

        if (!mta.verifyInitiatorProof(message, initiatorPublicKey, zk, nonce))
            throw new IllegalArgumentException("Invalid initiator %s proof for %s computation".formatted(initiatorPublicKey, type));

        return switch (type) {
            case GAMMA -> computeWithGamma(initiatorId, initiatorPublicKey, message.cA());
            case LAGRANGE -> computeWithLagrangeShare(initiatorId, initiatorPublicKey, zk, message.cA());
        };
    }

    private MtAResult computeWithGamma(int initiatorId, PaillierPublicKey publicKey, BigInt cA) {
        var gamma = context.crypto().ephemeral().gamma_i();
        var result = mta.computeCjWithY(publicKey, cA, gamma);
        var beta = result.y().negate().mod(context.crypto().curve().getCurveOrder());

        context.mta().respondent().storeBeta(initiatorId, beta);
        return result;
    }

    private MtAResult computeWithLagrangeShare(int initiatorId, PaillierPublicKey publicKey, ZKSetup zk, BigInt cA) {
        return context.crypto().useLagrangeShare(lagrangeShare -> {
            var nonce = context.init().additionalContext();

            var result = mta.computeCjWithY(publicKey, cA, lagrangeShare, zk, nonce);
            var nu = result.y().negate().mod(context.crypto().curve().getCurveOrder());

            context.mta().respondent().storeNu(initiatorId, nu);

            return result;
        });
    }
}
