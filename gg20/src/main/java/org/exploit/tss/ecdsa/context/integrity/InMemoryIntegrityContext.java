package org.exploit.tss.ecdsa.context.integrity;

import org.exploit.tss.curve.PointOps;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitment;
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitmentWithValue;
import org.exploit.tss.ecdsa.commitment.GammaCommitment;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class InMemoryIntegrityContext<P extends WeierstrassPointOps<P>> implements IntegrityContext<P> {
    private final Map<Integer, ChaumPedersenCommitmentWithValue<P>> lambdas = new ConcurrentHashMap<>();
    private final Map<Integer, GammaCommitment<P>> gammaCommits = new ConcurrentHashMap<>();
    private final Map<Integer, ChaumPedersenCommitment<P>> sigmaCommits = new ConcurrentHashMap<>();

    @Override
    public void storeLambda(int peerId, ChaumPedersenCommitmentWithValue<P> lambda) {
        lambdas.put(peerId, lambda);
    }

    @Override
    public void storeGammaCommitment(int peerId, GammaCommitment<P> gammaCommitment) {
        gammaCommits.put(peerId, gammaCommitment);
    }

    @Override
    public void storeSigmaCommitment(int peerId, ChaumPedersenCommitment<P> sigmaCommitment) {
        sigmaCommits.put(peerId, sigmaCommitment);
    }

    @Override
    public GammaCommitment<P> getGammaCommitment(int peerId) {
        return gammaCommits.get(peerId);
    }

    @Override
    public ChaumPedersenCommitment<P> getSigmaCommitment(int peerId) {
        return sigmaCommits.get(peerId);
    }

    @Override
    public PointOps<P> computeLambdaProduct(PointOps<P> clientLambda) {
        var result = clientLambda;

        for (var point: lambdas.values()) {
            result = result.add((P) point.value());
        }

        return result.normalize();
    }
}