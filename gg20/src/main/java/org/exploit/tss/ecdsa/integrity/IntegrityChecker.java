package org.exploit.tss.ecdsa.integrity;

import org.exploit.tss.curve.PointOps;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.ecdsa.GG20Client;
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitment;
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitmentWithValue;
import org.exploit.tss.ecdsa.context.GG20Context;
import org.exploit.tss.exception.IdentifiableAbortException;

public class IntegrityChecker<P extends WeierstrassPointOps<P>> {
    private final GG20Context<P> context;
    private final GG20Client<P> client;

    public IntegrityChecker(GG20Context<P> context, GG20Client<P> client) {
        this.context = context;
        this.client = client;
    }

    public void storeSigmaCommitment(int peerId, ChaumPedersenCommitment<P> commitment) {
        if (!client.generator().verifyChaumCommitment(commitment)) {
            throw new IdentifiableAbortException(peerId, "Invalid Sigma Commitment");
        }

        context.integrity().storeSigmaCommitment(peerId, commitment);
    }

    public void storeLambdaCommitment(int peerId, ChaumPedersenCommitmentWithValue<P> commitmentWithValue) {
        if (!client.generator().verifyChaumCommitment(commitmentWithValue.commitment())) {
            throw new IdentifiableAbortException(peerId, "Invalid Lambda Commitment");
        }

        context.integrity().storeLambda(peerId, commitmentWithValue);
    }

    public ChaumPedersenCommitment<P> computeSigmaCommitment() {
        var sigma = client.signature().computeSigmaShare();
        return client.generator().createChaumCommitment(sigma);
    }

    public ChaumPedersenCommitmentWithValue<P> computeLambdaI() {
        var k_i = context.crypto().ephemeral().k_i();
        var point = context.crypto().curve().getG().mul(k_i).normalize();

        var commitment = client.generator().createChaumCommitment(k_i);
        return new ChaumPedersenCommitmentWithValue<>(commitment, point);
    }

    public PointOps<P> computeLambdaProduct() {
        return context.integrity().computeLambdaProduct(computeLambdaI().value()).normalize();
    }
}
