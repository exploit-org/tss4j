package org.exploit.sodium.cipher;

import org.exploit.sodium.Sodium;

import java.util.Arrays;

public final class ChaCha20Poly1305Cipher implements Cipher {
    private static final Sodium S = Sodium.INSTANCE;

    private ChaCha20Poly1305Cipher() {
        if (S.sodium_init() < 0) {
            throw new IllegalStateException("libsodium initialization failed");
        }
    }

    private static class Holder {
        private static final ChaCha20Poly1305Cipher INSTANCE = new ChaCha20Poly1305Cipher();
    }

    public static ChaCha20Poly1305Cipher getInstance() {
        return Holder.INSTANCE;
    }

    @Override
    public byte[] encrypt(byte[] plaintext, byte[] associatedData, byte[] key) {
        validateKeyLength(key);

        var nonceLen = S.crypto_aead_xchacha20poly1305_ietf_npubbytes();
        var tagLen   = S.crypto_aead_xchacha20poly1305_ietf_abytes();

        var nonce = new byte[nonceLen];
        S.randombytes_buf(nonce, nonceLen);

        var cipherLen = (long) plaintext.length + tagLen;
        var cipher = new byte[(int) cipherLen];
        var outLen = new long[1];

        var rc = S.crypto_aead_xchacha20poly1305_ietf_encrypt(
                cipher, outLen,
                plaintext, plaintext.length,
                associatedData, associatedData != null ? associatedData.length : 0,
                null,
                nonce, key
        );

        if (rc != 0) {
            throw new IllegalStateException("Encryption failed, rc=" + rc);
        }

        var output = new byte[nonceLen + cipher.length];
        System.arraycopy(nonce, 0, output, 0, nonceLen);
        System.arraycopy(cipher, 0, output, nonceLen, cipher.length);
        return output;
    }

    @Override
    public byte[] decrypt(byte[] input, byte[] associatedData, byte[] key) {
        validateKeyLength(key);

        var nonceLen = S.crypto_aead_xchacha20poly1305_ietf_npubbytes();
        var tagLen   = S.crypto_aead_xchacha20poly1305_ietf_abytes();
        if (input.length < nonceLen + tagLen) {
            throw new IllegalArgumentException("Input too short");
        }

        var nonce = Arrays.copyOfRange(input, 0, nonceLen);
        var cipher = Arrays.copyOfRange(input, nonceLen, input.length);

        var plain = new byte[cipher.length - tagLen];
        var outLen = new long[1];

        var rc = S.crypto_aead_xchacha20poly1305_ietf_decrypt(
                plain, outLen,
                null,
                cipher, cipher.length,
                associatedData, associatedData != null ? associatedData.length : 0,
                nonce, key
        );

        if (rc != 0) {
            throw new IllegalStateException("Decryption failed, rc=" + rc);
        }

        return plain;
    }

    private static void validateKeyLength(byte[] key) {
        var expected = S.crypto_aead_xchacha20poly1305_ietf_keybytes();
        if (key == null || key.length != expected) {
            throw new IllegalArgumentException("Key must be " + expected + " bytes");
        }
    }
}
