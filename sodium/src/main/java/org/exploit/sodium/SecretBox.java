package org.exploit.sodium;

import com.sun.jna.Pointer;

import javax.security.auth.Destroyable;
import java.lang.ref.Cleaner;
import java.util.Arrays;
import java.util.function.Function;

public final class SecretBox implements Destroyable {
    private static final Sodium sodium = Sodium.INSTANCE;
    private static final Cleaner cleaner = Cleaner.create();

    private boolean destroyed = false;

    static {
        if (Sodium.INSTANCE.sodium_init() < 0) {
            throw new IllegalStateException("libsodium initialization failed");
        }
    }

    private final Pointer buf;
    private final int capacity;
    private final Cleaner.Cleanable cleanable;

    private static class State implements Runnable {
        private final Pointer buf;
        private final int capacity;

        State(Pointer buf, int capacity) {
            this.buf = buf;
            this.capacity = capacity;
        }

        @Override
        public void run() {
            sodium.sodium_memzero(buf, capacity);
            sodium.sodium_free(buf);
        }
    }

    private SecretBox(int capacity) {
        this.capacity = capacity;
        this.buf = sodium.sodium_malloc(capacity);
        if (buf == null)
            throw new OutOfMemoryError("sodium_malloc returned NULL");

        this.cleanable = cleaner.register(this, new State(buf, capacity));
    }

    public static SecretBox allocate(int capacity) {
        return new SecretBox(capacity);
    }

    public static SecretBox of(byte[] plaintext, byte[] key, boolean destroy) {
        if (key.length != Sodium.crypto_secretbox_KEYBYTES)
            throw new IllegalArgumentException("Key must be " + Sodium.crypto_secretbox_KEYBYTES + " bytes");
        var capacity = Sodium.crypto_secretbox_NONCEBYTES + plaintext.length + Sodium.crypto_secretbox_MACBYTES;
        var box = new SecretBox(capacity);
        box.writeEncrypted(plaintext, key);

        if (destroy) {
            Arrays.fill(plaintext, (byte) 0);
            Arrays.fill(key, (byte) 0);
        }

        return box;
    }

    public <R> R useDecrypted(byte[] key, Function<byte[], R> action) {
        byte[] plaintext = null;

        try {
            plaintext = readDecrypted(key);
            return action.apply(plaintext);
        } finally {
            if (plaintext != null) {
                Arrays.fill(plaintext, (byte) 0);
            }
        }
    }

    public void writeEncrypted(byte[] plaintext, byte[] key) {
        var nonce = new byte[Sodium.crypto_secretbox_NONCEBYTES];
        sodium.randombytes_buf(nonce, nonce.length);

        var ctLen = plaintext.length + Sodium.crypto_secretbox_MACBYTES;
        var ct = new byte[ctLen];
        var rc = sodium.crypto_secretbox_easy(ct, plaintext, plaintext.length, nonce, key);

        if (rc != 0)
            throw new IllegalStateException("Encryption failed");

        buf.write(0, nonce, 0, nonce.length);
        buf.write(nonce.length, ct, 0, ct.length);
        Arrays.fill(plaintext, (byte) 0);
    }

    public byte[] readDecrypted(byte[] key) {
        if (key.length != Sodium.crypto_secretbox_KEYBYTES)
            throw new IllegalArgumentException("Key must be " + Sodium.crypto_secretbox_KEYBYTES + " bytes");

        var nonce = buf.getByteArray(0, Sodium.crypto_secretbox_NONCEBYTES);
        var ctLen = capacity - Sodium.crypto_secretbox_NONCEBYTES;

        var ct = buf.getByteArray(Sodium.crypto_secretbox_NONCEBYTES, ctLen);
        var m = new byte[ctLen - Sodium.crypto_secretbox_MACBYTES];
        var rc = sodium.crypto_secretbox_open_easy(m, ct, ctLen, nonce, key);

        if (rc != 0)
            throw new IllegalStateException("Decryption failed");

        return m;
    }

    @Override
    public boolean isDestroyed() {
        return destroyed;
    }

    @Override
    public void destroy() {
        cleanable.clean();
        destroyed = true;
    }
}