package org.exploit.sodium;

import com.sun.jna.Pointer;

import java.lang.ref.Cleaner;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.function.Function;

public final class ReadOnlyBuffer implements AutoCloseable {
    private final Pointer ptr;
    private final int len;
    private final int allocLen;
    private final Cleaner.Cleanable cleanable;
    private volatile boolean closed = false;

    private static final Cleaner cleaner = Cleaner.create();
    private static final Sodium S = Sodium.INSTANCE;

    static {
        if (S.sodium_init() < 0) {
            throw new IllegalStateException("Couldn't init libsodium");
        }
    }

    private static final class State implements Runnable {
        private final Pointer p;
        State(Pointer p) { this.p = p; }
        @Override public void run() { S.sodium_free(p); }
    }

    public ReadOnlyBuffer(byte[] src) {
        this.len = src.length;
        int pageSize = CLibrary.INSTANCE.getpagesize();
        this.allocLen = ((len + pageSize - 1) / pageSize) * pageSize;

        this.ptr = S.sodium_malloc(allocLen);
        if (ptr == null)
            throw new OutOfMemoryError("sodium_malloc ");

        S.sodium_mlock(ptr, allocLen);
        ptr.write(0, src, 0, len);
        Arrays.fill(src, (byte) 0);

        S.sodium_mprotect_readonly(ptr);
        this.cleanable = cleaner.register(this, new State(ptr));
    }

    public byte[] read() {
        ensureOpen();
        byte[] out = new byte[len];
        ptr.read(0, out, 0, len);
        return out;
    }

    public <T> T read(Function<byte[], T> fn) {
        byte[] data = read();
        try {
            return fn.apply(data);
        } finally {
            Arrays.fill(data, (byte) 0);
        }
    }

    public ByteBuffer asReadOnlyByteBuffer() {
        ensureOpen();

        var buf = ptr.getByteBuffer(0, allocLen);
        buf.limit(len);
        return buf.asReadOnlyBuffer();
    }

    @Override
    public void close() {
        if (!closed) {
            closed = true;
            cleanable.clean();
        }
    }

    private void ensureOpen() {
        if (closed) throw new IllegalStateException("Buffer closed");
    }
}