package org.exploit.sodium;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Pointer;

public interface Sodium extends Library {
    Sodium INSTANCE = Native.load("sodium", Sodium.class);

    int sodium_init();

    int crypto_core_ed25519_BYTES = 32;
    int crypto_core_ed25519_UNIFORMBYTES = 64;
    int crypto_core_ed25519_SCALARBYTES = 32;
    int crypto_core_ed25519_NONREDUCEDSCALARBYTES = 64;
    int crypto_scalarmult_ed25519_BYTES = 32;
    int crypto_scalarmult_ed25519_SCALARBYTES = 32;

    int crypto_sign_ed25519_PUBLICKEYBYTES = 32;
    int crypto_sign_ed25519_SECRETKEYBYTES = 64;
    int crypto_sign_ed25519_BYTES = 64;
    int crypto_sign_ed25519_SEEDBYTES = 32;

    int crypto_sign_ed25519_keypair(byte[] pk, byte[] sk);
    int crypto_sign_ed25519_seed_keypair(byte[] pk, byte[] sk, byte[] seed);

    int crypto_sign_ed25519_detached(
            byte[] sig,
            long[] siglen,
            byte[] m,
            long mlen,
            byte[] sk
    );

    int crypto_sign_ed25519_verify_detached(
            byte[] sig,
            byte[] m,
            long mlen,
            byte[] pk
    );

    int crypto_sign_ed25519(
            byte[] sm,
            long[] smlen,
            byte[] m,
            long mlen,
            byte[] sk
    );

    int crypto_sign_ed25519_open(
            byte[] m,
            long[] mlen,
            byte[] sm,
            long smlen,
            byte[] pk
    );

    int sodium_mprotect_noaccess(Pointer ptr);
    int sodium_mprotect_readonly(Pointer ptr);
    int sodium_mprotect_readwrite(Pointer ptr);

    int crypto_core_ed25519_add(byte[] r, byte[] p, byte[] q);

    int crypto_core_ed25519_sub(byte[] r, byte[] p, byte[] q);

    int crypto_core_ed25519_is_valid_point(byte[] p);
    void crypto_core_ed25519_random(byte[] p);
    int crypto_core_ed25519_from_uniform(byte[] p, byte[] uniform);

    int crypto_scalarmult_ed25519(byte[] q, byte[] scalar, byte[] p);

    int crypto_scalarmult_ed25519_base(byte[] q, byte[] scalar);

    int crypto_scalarmult_ed25519_noclamp(byte[] q, byte[] scalar, byte[] p);
    int crypto_scalarmult_ed25519_base_noclamp(byte[] q, byte[] scalar);

    void crypto_core_ed25519_scalar_random(byte[] r);
    void crypto_core_ed25519_scalar_reduce(byte[] r, byte[] s);

    int crypto_core_ed25519_scalar_invert(byte[] recip, byte[] s);

    void crypto_core_ed25519_scalar_negate(byte[] neg, byte[] s);

    void crypto_core_ed25519_scalar_complement(byte[] comp, byte[] s);

    void crypto_core_ed25519_scalar_add(byte[] z, byte[] x, byte[] y);

    void crypto_core_ed25519_scalar_sub(byte[] z, byte[] x, byte[] y);

    void crypto_core_ed25519_scalar_mul(byte[] z, byte[] x, byte[] y);

    Pointer sodium_malloc(long size);

    void sodium_free(Pointer ptr);

    int sodium_mlock(Pointer ptr, long len);
    int sodium_munlock(Pointer ptr, long len);

    void sodium_memzero(Pointer ptr, long len);

    void randombytes_buf(byte[] buf, long size);

    int crypto_secretbox_KEYBYTES = 32;
    int crypto_secretbox_NONCEBYTES = 24;
    int crypto_secretbox_MACBYTES = 16;

    int crypto_secretbox_easy(
        byte[] c, byte[] m, long mlen,
        byte[] nonce, byte[] key
    );
    int crypto_secretbox_open_easy(
        byte[] m, byte[] c, long clen,
        byte[] nonce, byte[] key
    );

    int crypto_aead_xchacha20poly1305_ietf_keybytes();
    int crypto_aead_xchacha20poly1305_ietf_npubbytes();
    int crypto_aead_xchacha20poly1305_ietf_abytes();

    int crypto_aead_xchacha20poly1305_ietf_encrypt(
            byte[] c,
            long[] clen,
            byte[] m, long mlen,
            byte[] ad, long adlen,
            Pointer nsec,
            byte[] npub,
            byte[] k
    );

    int crypto_aead_xchacha20poly1305_ietf_decrypt(
            byte[] m,
            long[] mlen,
            Pointer nsec,
            byte[] c, long clen,
            byte[] ad, long adlen,
            byte[] npub,
            byte[] k
    );
}