package org.exploit.ecies.test;

import org.exploit.ecies.ThresholdECIESClient;
import org.exploit.ecies.cipher.AesGcmCipher;
import org.exploit.ecies.context.ECIESContext;
import org.exploit.ecies.context.aggregator.InMemoryPartialDecryptContext;
import org.exploit.ecies.context.crypto.InMemoryCryptoContext;
import org.exploit.ecies.model.CipherText;
import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.sodium.SecretBox;
import org.exploit.tss.TSS;
import org.exploit.tss.key.RawKeyPair;
import org.exploit.tss.shamir.ECShamirKeySplitter;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

class ThresholdECIESTest {
    private static final byte[] MEM_KEY = new byte[32];
    private static final List<Integer> PARTICIPANTS = List.of(1, 2, 3, 4);
    private static final int THRESHOLD = 2;

    static {
        ZKRandom.getRandom().nextBytes(MEM_KEY);
    }

    private Secp256k1CurveParams curve;
    private byte[] plaintext;
    private RawKeyPair masterKP;

    private final Map<Integer, ThresholdECIESClient<Secp256k1PointOps>> clients = new HashMap<>();

    @BeforeEach
    void setUp() {
        TSS.loadLibraries();

        curve = new Secp256k1CurveParams();
        plaintext = "Threshold ECIES".getBytes(UTF_8);
        masterKP = Secp256k1.generateKeyPair();

        var splitter = new ECShamirKeySplitter<>(curve.getCurveOrder(), curve.getG(), THRESHOLD, PARTICIPANTS.size());

        var x = new BigInt(1, masterKP.getSecretKey());
        var shares = splitter.splitKey(x).shares();

        var cipher = new AesGcmCipher();
        for (var share : shares) {
            var cryptoCtx = InMemoryCryptoContext.<Secp256k1PointOps>builder()
                    .idx(share.index())
                    .ski(SecretBox.of(share.share().toByteArray(), MEM_KEY, false))
                    .memKey(MEM_KEY::clone)
                    .curve(curve)
                    .participants(PARTICIPANTS)
                    .publicKey(curve.decodePoint(masterKP.getPublicKey()))
                    .build();

            var decryptCtx = new InMemoryPartialDecryptContext<Secp256k1PointOps>();

            var ctx = new ECIESContext<>(cryptoCtx, decryptCtx);
            clients.put(share.index(), new ThresholdECIESClient<>(ctx, cipher));
        }
    }

    @Test
    void endToEnd() {
        var initiator = clients.get(PARTICIPANTS.get(0));
        System.out.println("Plain text: " + new String(plaintext));

        var ct = initiator.encryptor().encrypt(plaintext);
        var encodedCt = ct.encode();
        var decodedCt = CipherText.decode(encodedCt);

        System.out.println("Encrypted: " + ct);

        for (int idx : PARTICIPANTS) {
            if (idx == initiator.context().crypto().idx())
                continue;

            var part = clients.get(idx)
                    .decryptor()
                    .partialDecrypt(decodedCt);

            initiator.context().decrypt().storePartialDecrypt(part);
        }

        var decrypted = initiator.combiner().decrypt(decodedCt);
        System.out.println("Decrypted: " + new String(decrypted));
        assertArrayEquals(plaintext, decrypted);
    }
}