package org.exploit.ecies.partial;

import org.exploit.ecies.ThresholdECIESClient;
import org.exploit.ecies.cipher.SymmetricCipher;
import org.exploit.ecies.model.CipherText;
import org.exploit.ecies.model.PartialDecrypt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.exception.IdentifiableAbortException;
import org.exploit.tss.proof.dleq.DleqProofValidator;
import org.exploit.tss.proof.model.context.DleqContext;
import org.exploit.tss.util.Polynomials;

import java.util.ArrayList;
import java.util.Arrays;

import static org.exploit.ecies.util.HKDF.hkdf;

public class PartialDecryptCombiner<P extends WeierstrassPointOps<P>> {
    private final ThresholdECIESClient<P> client;
    private final SymmetricCipher cipher;
    private final DleqProofValidator<P> validator;

    public PartialDecryptCombiner(ThresholdECIESClient<P> client, SymmetricCipher cipher) {
        this.client = client;
        this.cipher = cipher;

        var curve = client.context().crypto().curve();

        this.validator = new DleqProofValidator<>(curve.getCurveOrder(), (WeierstrassPointOps<P>) curve.getG());
    }

    public byte[] decrypt(CipherText ct) {
        var curve = client.context().crypto().curve();
        var parts = new ArrayList<>(client.context().decrypt().getPartialDecrypts());
        parts.add(client.decryptor().partialDecrypt(ct));

        var q = curve.getCurveOrder();
        var R = (P) curve.decodePoint(ct.getR());
        var indices = parts.stream().map(PartialDecrypt::idx).toList();

        for (var pd : parts) {
            var di = (P) curve.decodePoint(pd.di());
            var ctx = new DleqContext<>(R, pd.Yi(), di);

            if (!validator.verifyProof(pd.proof(), ctx, null))
                throw new IdentifiableAbortException(pd.idx(), "Bad DLEQ proof");
        }

        var S = curve.getInfinity();
        for (var pd : parts) {
            var di = (P) curve.decodePoint(pd.di());
            var l = Polynomials.computeLagrangeCoefficient(pd.idx(), indices, q);

            S = S.add(di.mul(l)).normalize();
        }

        var key = hkdf(S.encode(true), R.encode(true));
        var kEnc = Arrays.copyOfRange(key, 0, 32);
        var iv = Arrays.copyOfRange(key, 32, 44);

        try {
            return cipher.decrypt(kEnc, iv, ct.getC(), ct.getTag(), R.encode(true));
        } finally {
            Arrays.fill(key, (byte) 0);
            Arrays.fill(kEnc, (byte) 0);
        }
    }
}