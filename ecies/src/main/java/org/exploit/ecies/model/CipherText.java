package org.exploit.ecies.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.exploit.tss.util.Bytes;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.UncheckedIOException;

import static java.util.Base64.getDecoder;
import static java.util.Base64.getEncoder;

@Getter
@AllArgsConstructor
public class CipherText {
    private final byte[] R;
    private final byte[] c;
    private final byte[] tag;

    public String encode64() {
        var r64 = getEncoder().encodeToString(R == null ? new byte[0] : R);
        var c64 = getEncoder().encodeToString(c == null ? new byte[0] : c);
        var tag64 = getEncoder().encodeToString(tag == null ? new byte[0] : tag);

        return String.format("%s.%s.%s", r64, c64, tag64);
    }

    public byte[] encode() {
        return Bytes.encode(R, c, tag);
    }

    public static CipherText decode64(String encoded) {
        var parts = encoded.split("\\.");
        if (parts.length != 3) {
            throw new IllegalArgumentException("Invalid encoded cipher text format");
        }

        var r = getDecoder().decode(parts[0]);
        var c = getDecoder().decode(parts[1]);
        var tag = getDecoder().decode(parts[2]);

        return new CipherText(r, c, tag);
    }

    public static CipherText decode(byte[] ct) {
        try (var in = new ByteArrayInputStream(ct); var din = new DataInputStream(in)) {
            var r = readPart(din);
            var c = readPart(din);
            var tag = readPart(din);

            if (in.available() > 0) {
                throw new IllegalArgumentException("Invalid cipher text format");
            }

            return new CipherText(r, c, tag);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private static byte[] readPart(DataInputStream in) throws IOException {
        var size = in.readInt();
        if (size < 0) {
            throw new IllegalArgumentException("Invalid cipher text format");
        }

        var part = new byte[size];
        if (in.read(part) != size) {
            throw new IllegalArgumentException("Invalid cipher text format");
        }

        return part;
    }
}
