package org.exploit.tss.frost.secp256k1.verify;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.tss.frost.hash.FrostHash;

import java.util.Arrays;

public final class Secp256k1Frost {
    private Secp256k1Frost() {}

    private static final Secp256k1CurveParams CURVE_PARAMS = new Secp256k1CurveParams();

    public static boolean schnorrVerify(byte[] msg, byte[] sig65, byte[] pk33) {
        if (sig65 == null || sig65.length != 65) return false;
        if (pk33 == null || pk33.length != 33) return false;

        var R33 = Arrays.copyOfRange(sig65, 0, 33);
        var z32 = Arrays.copyOfRange(sig65, 33, 65);

        var R = CURVE_PARAMS.decodePoint(R33);
        var PK = CURVE_PARAMS.decodePoint(pk33);

        var n = Secp256k1CurveParams.CURVE_ORDER;

        var z = new BigInt(1, z32);
        if (z.compareTo(n) >= 0) return false;

        var c = FrostHash.H2(R, PK, msg, n);

        var lhs = CURVE_PARAMS.getG().mul(z).normalize();
        var rhs = R.add(PK.mul(c).normalize()).normalize();

        return lhs.equals(rhs);
    }
}
