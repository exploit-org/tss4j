package org.exploit.tss.frost.secp256k1.ciphersuite;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.frost.ciphersuite.FrostCipherSuite;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.util.Bytes;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public final class FrostSecp256k1Sha256V1CipherSuite implements FrostCipherSuite<Secp256k1PointOps> {
    private static final byte[] CONTEXT = "FROST-secp256k1-SHA256-v1".getBytes(StandardCharsets.US_ASCII);

    private static final byte[] DST_RHO = Bytes.concat(CONTEXT, "rho".getBytes(StandardCharsets.US_ASCII));
    private static final byte[] DST_CHAL = Bytes.concat(CONTEXT, "chal".getBytes(StandardCharsets.US_ASCII));
    private static final int L = 48;

    @Override
    public BigInt h1(int idx, byte[] msgPrepared, List<ParticipantCommitment<Secp256k1PointOps>> B, BigInt q) {
        var m = Bytes.concat(int32be(idx), encodeCommitListDeterministic(B), nz(msgPrepared));

        return hashToScalarXmdSha256(m, DST_RHO, q);
    }

    @Override
    public BigInt h2(Secp256k1PointOps R, Secp256k1PointOps Y, byte[] msgPrepared, BigInt q) {
        var m = Bytes.concat(
                R.encode(true),
                Y.encode(true),
                nz(msgPrepared)
        );

        return hashToScalarXmdSha256(m, DST_CHAL, q);
    }

    private static BigInt hashToScalarXmdSha256(byte[] msg, byte[] dst, BigInt q) {
        var uniform = Secp256k1.expandMessageXmd("SHA-256", 64, msg, dst, L);
        return new BigInt(1, uniform).mod(q);
    }

    private static byte[] encodeCommitListDeterministic(List<ParticipantCommitment<Secp256k1PointOps>> list) {
        if (list == null || list.isEmpty()) return new byte[0];

        var copy = new ArrayList<>(list);
        copy.sort(Comparator.comparingInt(ParticipantCommitment::idx));

        var chunks = new ArrayList<byte[]>(copy.size());
        for (var pc : copy) {
            chunks.add(Bytes.concat(
                    int32be(pc.idx()),
                    pc.D().encode(true),
                    pc.E().encode(true)
            ));
        }
        return Bytes.concat(chunks);
    }

    private static byte[] int32be(int x) {
        return ByteBuffer.allocate(4).putInt(x).array();
    }

    private static byte[] nz(byte[] b) {
        return b == null ? new byte[0] : b;
    }
}