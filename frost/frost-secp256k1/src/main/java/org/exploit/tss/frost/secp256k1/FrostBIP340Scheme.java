package org.exploit.tss.frost.secp256k1;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.frost.ciphersuite.FrostCipherSuite;
import org.exploit.tss.frost.model.ContextOfR;
import org.exploit.tss.frost.schema.DefaultFrostScheme;
import org.exploit.tss.frost.secp256k1.ciphersuite.FrostSecp256k1Sha256V1CipherSuite;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

public final class FrostBIP340Scheme extends DefaultFrostScheme<Secp256k1PointOps> {
    @Override
    protected FrostCipherSuite<Secp256k1PointOps> cipherSuite() {
        return new FrostSecp256k1Sha256V1CipherSuite();
    }

    @Override
    public byte[] prepareMessage(byte[] msg) {
        if (msg == null || msg.length != 32)
            throw new IllegalArgumentException("BIP340 requires msg32");

        return msg;
    }

    @Override
    public ContextOfR<Secp256k1PointOps> computeRCtx(Secp256k1PointOps Rraw) {
        var R = Rraw.normalize();
        if (hasEvenY(R)) {
            return new ContextOfR<>(R, false);
        }
        return new ContextOfR<>(R.negate().normalize(), true);
    }

    @Override
    public BigInt h2(ContextOfR<Secp256k1PointOps> rCtx, Secp256k1PointOps Y, byte[] msgPrepared, BigInt q) {
        var Ycanon = canonPubkey(Y);

        var r32 = xOnly32(rCtx.canon());
        var pk32 = xOnly32(Ycanon);

        var eBytes = Hash.taggedHash(Bytes.concat(r32, pk32, msgPrepared), "BIP0340/challenge");
        return new BigInt(1, eBytes).mod(q);
    }

    @Override
    public BigInt applyShareTerm(BigInt share, BigInt c, Secp256k1PointOps Y, BigInt q) {
        var term = share.multiplySec(c).mod(q);
        if (negateKeyTerm(Y)) {
            term = q.subtract(term).mod(q);
        }
        return term;
    }

    @Override
    public BigInt keyCoefficient(BigInt lambda, BigInt c, Secp256k1PointOps Y, BigInt q) {
        var k = lambda.multiply(c).mod(q);
        if (negateKeyTerm(Y)) {
            k = q.subtract(k).mod(q);
        }
        return k;
    }

    @Override
    public BigInt finalizeS(BigInt zSum, BigInt c, Secp256k1PointOps Y, BigInt q) {
        return zSum.mod(q);
    }

    @Override
    public SchnorrSignature buildSignature(ContextOfR<Secp256k1PointOps> rCtx, BigInt sFinal, BigInt q) {
        var r32 = xOnly32(rCtx.canon());
        var s32 = Secp256k1PointOps.to32(sFinal.mod(q));
        return new SchnorrSignature(r32, s32);
    }

    private static boolean negateKeyTerm(Secp256k1PointOps Y) {
        return !hasEvenY(Y.normalize());
    }

    private static Secp256k1PointOps canonPubkey(Secp256k1PointOps Y) {
        var p = Y.normalize();
        return hasEvenY(p) ? p : p.negate().normalize();
    }

    private static boolean hasEvenY(Secp256k1PointOps p) {
        var y = p.getAffineY();
        return !y.testBit(0);
    }

    private static byte[] xOnly32(Secp256k1PointOps p) {
        return p.getAffineX().toUnsignedByteArray(32);
    }
}