package org.exploit.tss.frost.taproot;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.secp256k1.taproot.Taproot;
import org.exploit.tss.frost.hash.FrostHash;
import org.exploit.tss.frost.model.ContextOfR;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.frost.schema.FrostScheme;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.util.List;

public final class FrostTaprootScheme implements FrostScheme<Secp256k1PointOps> {
    private static final Secp256k1CurveParams CURVE_PARAMS = new Secp256k1CurveParams();

    private final byte[] merkleRoot;

    public FrostTaprootScheme(byte[] merkleRoot) {
        this.merkleRoot = merkleRoot == null ? new byte[0] : merkleRoot.clone();
    }

    @Override
    public byte[] prepareMessage(byte[] msg) {
        if (msg == null || msg.length != 32)
            throw new IllegalArgumentException("BIP340/Taproot requires msg32");
        return msg;
    }

    @Override
    public BigInt h1(int idx, byte[] msgPrepared, byte[] additionalContext, List<ParticipantCommitment<Secp256k1PointOps>> B, BigInt q) {
        return FrostHash.H1(idx, msgPrepared, additionalContext, B, q);
    }

    @Override
    public ContextOfR<Secp256k1PointOps> computeRCtx(Secp256k1PointOps raw) {
        var R = raw.normalize();
        if (hasEvenY(R)) {
            return new ContextOfR<>(R, false);
        }
        return new ContextOfR<>(R.negate().normalize(), true);
    }

    @Override
    public BigInt h2(ContextOfR<Secp256k1PointOps> rCtx, Secp256k1PointOps Y, byte[] msgPrepared, byte[] additionalContext, BigInt n) {
        var info = keyInfo(Y, n);

        var r32 = Taproot.xOnly(rCtx.canon());
        var pk32 = Taproot.xOnly(info.Qeven);

        var eBytes = Hash.taggedHash(Bytes.concat(r32, pk32, msgPrepared), "BIP0340/challenge");
        return new BigInt(1, eBytes).mod(n);
    }

    @Override
    public BigInt applyShareTerm(BigInt share, BigInt c, Secp256k1PointOps Y, BigInt n) {
        var info = keyInfo(Y, n);
        var term = share.multiplySec(c).mod(n);
        if (info.negateKeyTerm) {
            term = n.subtract(term).mod(n);
        }
        return term;
    }

    @Override
    public BigInt keyCoefficient(BigInt lambda, BigInt c, Secp256k1PointOps Y, BigInt n) {
        var info = keyInfo(Y, n);
        var k = lambda.multiply(c).mod(n);
        if (info.negateKeyTerm) {
            k = n.subtract(k).mod(n);
        }
        return k;
    }

    @Override
    public BigInt finalizeS(BigInt zSum, BigInt c, Secp256k1PointOps Y, BigInt n) {
        var info = keyInfo(Y, n);
        var tweakTerm = c.multiplySec(info.t).mod(n);
        if (info.negateTweakTerm) {
            tweakTerm = n.subtract(tweakTerm).mod(n);
        }
        return zSum.add(tweakTerm).mod(n);
    }

    @Override
    public SchnorrSignature buildSignature(ContextOfR<Secp256k1PointOps> rCtx, BigInt sFinal, BigInt n) {
        var r32 = Taproot.xOnly(rCtx.canon());
        var s32 = Secp256k1PointOps.to32(sFinal.mod(n));
        return new SchnorrSignature(r32, s32);
    }

    private KeyInfo keyInfo(Secp256k1PointOps Y, BigInt n) {
        var g = CURVE_PARAMS.getG();

        var yOdd = !hasEvenY(Y);
        var Yeven = yOdd ? Y.negate().normalize() : Y.normalize();

        var internalX = Taproot.xOnly(Yeven);

        var tweakBytes = Hash.taggedHash(Bytes.concat(internalX, merkleRoot), "TapTweak");
        var t = new BigInt(1, tweakBytes);

        if (t.compareTo(n) >= 0)
            throw new IllegalArgumentException("TapTweak scalar t >= n");

        var Qraw = Yeven.add(g.mul(t).normalize()).normalize();

        var qOdd = !hasEvenY(Qraw);
        var Qeven = qOdd ? Qraw.negate().normalize() : Qraw;

        var negateKeyTerm = yOdd ^ qOdd;

        return new KeyInfo(Qeven, t, negateKeyTerm, qOdd);
    }

    private static boolean hasEvenY(Secp256k1PointOps p) {
        var y = p.getAffineY();
        return !y.testBit(0);
    }

    private record KeyInfo(Secp256k1PointOps Qeven, BigInt t, boolean negateKeyTerm, boolean negateTweakTerm) {}
}