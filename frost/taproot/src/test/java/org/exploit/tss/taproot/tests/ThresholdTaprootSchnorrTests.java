package org.exploit.tss.taproot.tests;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.secp256k1.XOnlyPublicKey;
import org.exploit.sodium.SecretBox;
import org.exploit.tss.TSS;
import org.exploit.tss.frost.FrostClient;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.context.crypto.InMemoryCryptoContext;
import org.exploit.tss.frost.taproot.FrostTaprootScheme;
import org.exploit.tss.key.RawKeyPair;
import org.exploit.tss.shamir.ECShamirKeySplitter;
import org.exploit.tss.shamir.model.ECKeyShare;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class ThresholdTaprootSchnorrTests {
    private static final byte[] MEMORY_ENCRYPT_KEY = new byte[32];
    private static final byte[] CONTEXT = "TEST.CONTEXT".getBytes();

    private final String sessionId = "TEST";

    private final byte[] merkleRoot = new byte[0];

    private final Map<String, byte[]> operations = generateThousandOfOperations();

    private final List<Integer> participants = List.of(1, 2, 3, 4);
    private final Map<Integer, FrostClient<Secp256k1PointOps>> clients = new HashMap<>();
    private final Secp256k1CurveParams curveParams = new Secp256k1CurveParams();

    private final RawKeyPair keyPair = Secp256k1.generateKeyPair();
    private final XOnlyPublicKey xonlyPk = Secp256k1.xonlyFromSecret(keyPair.getSecretKey());

    static {
        TSS.loadLibraries();
        ZKRandom.getRandom().nextBytes(MEMORY_ENCRYPT_KEY);
    }

    @BeforeEach
    public void init() {
        var splitter = new ECShamirKeySplitter<>(curveParams.getCurveOrder(), curveParams.getG(), 2, 4);
        var result = splitter.splitKey(toBigInt(keyPair.getSecretKey()));
        var reconstructed = splitter.recoverKey(result.shares());

        assertEquals(toBigInt(keyPair.getSecretKey()), reconstructed);

        for (var share : result.shares()) {
            var client = createClient(share);
            clients.put(share.index(), client);
        }
    }

    @Test
    public void testValidSignatureTaproot() {
        var coordinator = clients.get(participants.get(0));

        for (var opId : operations.keySet()) {
            prepareCommitments(opId);
        }

        for (var opId : operations.keySet()) {
            aggregateZ(opId, coordinator);
        }

        for (var opId : operations.keySet()) {
            var sig = coordinator.aggregator().computeSignature(opId);
            assertTrue(Secp256k1.taprootVerify(operations.get(opId), sig.encode(), xonlyPk.getBytes(), merkleRoot));
        }
    }

    private void prepareCommitments(String opId) {
        for (var client : clients.values()) {
            var idx = client.context().crypto().idx();
            var commitment = client.preProcessor().generateCommitment(opId).toParticipant(idx);

            for (var i : participants) {
                if (i == idx)
                    continue;

                var clientJ = clients.get(i);
                clientJ.signature().storeCommitment(idx, opId, commitment);
            }
        }
    }

    private void aggregateZ(String opId, FrostClient<Secp256k1PointOps> coordinator) {
        for (var client : clients.values()) {
            coordinator.aggregator().storeZ(
                    client.context().crypto().idx(),
                    opId,
                    client.signature().computeZ(opId)
            );
        }
    }

    private FrostClient<Secp256k1PointOps> createClient(ECKeyShare<Secp256k1PointOps> share) {
        var publicKeyPoint = Secp256k1PointOps.fromBytes(keyPair.getPublicKey());

        var cryptoContext = new InMemoryCryptoContext<>(
                share.index(),
                participants,
                new Secp256k1CurveParams(),
                SecretBox.of(share.share().toByteArray(), MEMORY_ENCRYPT_KEY, false),
                publicKeyPoint,
                MEMORY_ENCRYPT_KEY::clone
        );

        var frostContext = FrostContext.newBuilder(Secp256k1PointOps.class)
                .crypto(cryptoContext)
                .operations(operations)
                .aad(CONTEXT)
                .build();

        return new FrostClient<>(sessionId, frostContext, new FrostTaprootScheme(merkleRoot));
    }

    private static Map<String, byte[]> generateThousandOfOperations() {
        Map<String, byte[]> ops = new HashMap<>();
        for (int i = 0; i < 1000; i++) {
            ops.put("OP_" + i, Hash.sha256(("Hello World " + i).getBytes()));
        }
        return ops;
    }

    private static BigInt toBigInt(byte[] be) {
        return new BigInt(1, be);
    }
}