package org.exploit.tss.frost.ed25519;

import org.exploit.ed25519.Ed25519;
import org.exploit.ed25519.Ed25519CurveParams;
import org.exploit.ed25519.Ed25519PointOps;
import org.exploit.ed25519.RawEd25519KeyPair;
import org.exploit.ed25519.rfc8032.Ed25519Clamp;
import org.exploit.sodium.SecretBox;
import org.exploit.tss.TSS;
import org.exploit.tss.frost.FrostClient;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.context.crypto.InMemoryCryptoContext;
import org.exploit.tss.shamir.ECShamirKeySplitter;
import org.exploit.tss.shamir.model.ECKeyShare;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ThresholdEd25519Tests {
    private static final byte[] MEMORY_ENCRYPT_KEY = new byte[32];
    private static final byte[] CONTEXT = "TEST.CONTEXT".getBytes();

    private final String sessionId = "TEST";

    private final List<Integer> participants = List.of(1, 2, 3, 4);
    private final Map<Integer, FrostClient<Ed25519PointOps>> clients = new HashMap<>();
    private final Ed25519CurveParams curveParams = new Ed25519CurveParams();

    private final RawEd25519KeyPair keyPair = Ed25519.generateKeyPair();

    private final Map<String, byte[]> operations = generateThousandOfOperations();

    static {
        TSS.loadLibraries();
        ZKRandom.getRandom().nextBytes(MEMORY_ENCRYPT_KEY);
    }

    @BeforeEach
    public void init() {
        var splitter = new ECShamirKeySplitter<>(curveParams.getCurveOrder(), curveParams.getG(), 2, 4);
        var result = splitter.splitKey(Ed25519Clamp.toBigInt(keyPair.getSecretKey()));
        var reconstructed = splitter.recoverKey(result.shares());

        Assertions.assertEquals(Ed25519Clamp.toBigInt(keyPair.getSecretKey()), reconstructed);

        for (var share : result.shares()) {
            var client = createClient(share);
            clients.put(share.index(), client);
        }
    }

    @Test
    public void testValidSignature() {
        var coordinator = clients.get(participants.get(0));

        for (var opId : operations.keySet()) {
            prepareCommitments(opId);
        }

        for (var opId : operations.keySet()) {
            aggregateZ(opId, coordinator);
        }

        for (var opId : operations.keySet()) {
            var signature = coordinator.aggregator().computeSignature(opId);
            Assertions.assertTrue(Ed25519.verifyDetached(operations.get(opId), signature.encode(), keyPair.getPublicKey()));
        }
    }

    private void prepareCommitments(String opId) {
        for (var client : clients.values()) {
            var idx = client.context().crypto().idx();
            var commitment = client.preProcessor().generateCommitment(opId).toParticipant(idx);

            for (var i : participants) {
                if (i == idx)
                    continue;

                var clientJ = clients.get(i);
                clientJ.signature().storeCommitment(idx, opId, commitment);
            }
        }
    }

    private void aggregateZ(String opId, FrostClient<Ed25519PointOps> coordinator) {
        for (var client : clients.values()) {
            coordinator.aggregator().storeZ(client.context().crypto().idx(), opId, client.signature().computeZ(opId));
        }
    }

    private FrostClient<Ed25519PointOps> createClient(ECKeyShare<Ed25519PointOps> share) {
        var publicKeyPoint = new Ed25519PointOps(keyPair.getPublicKey());

        var cryptoContext = new InMemoryCryptoContext<>(
                share.index(),
                participants,
                new Ed25519CurveParams(),
                SecretBox.of(share.share().toByteArray(), MEMORY_ENCRYPT_KEY, false),
                publicKeyPoint,
                MEMORY_ENCRYPT_KEY::clone
        );

        var frostContext = FrostContext.newBuilder(Ed25519PointOps.class)
                .crypto(cryptoContext)
                .operations(operations)
                .aad(CONTEXT)
                .build();

        return new FrostClient<>(sessionId, frostContext, new FrostEd25519Scheme());
    }

    private Map<String, byte[]> generateThousandOfOperations() {
        Map<String, byte[]> ops = new HashMap<>();
        for (int i = 0; i < 1000; i++) {
            ops.put("OP_" + i, Hash.sha256(("Hello World " + i).getBytes()));
        }
        return ops;
    }
}
