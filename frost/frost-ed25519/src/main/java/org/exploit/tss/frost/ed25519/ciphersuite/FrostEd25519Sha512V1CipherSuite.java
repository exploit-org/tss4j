package org.exploit.tss.frost.ed25519.ciphersuite;

import org.exploit.ed25519.Ed25519PointOps;
import org.exploit.gmp.BigInt;
import org.exploit.tss.frost.ciphersuite.FrostCipherSuite;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.util.Hash;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.exploit.tss.util.Bytes.concat;

public final class FrostEd25519Sha512V1CipherSuite implements FrostCipherSuite<Ed25519PointOps> {
    private static final byte[] CONTEXT = "FROST-ED25519-SHA512-v1".getBytes(StandardCharsets.US_ASCII);
    private static final byte[] RHO = "rho".getBytes(StandardCharsets.US_ASCII);

    @Override
    public BigInt h1(int idx, byte[] msgPrepared, List<ParticipantCommitment<Ed25519PointOps>> B, BigInt q) {
        var m = concat(int32be(idx), encodeCommitListDeterministic(B), nz(msgPrepared));
        var digest = Hash.sha512(concat(CONTEXT, RHO, m));
        return fromLittleEndian(digest).mod(q);
    }

    @Override
    public BigInt h2(Ed25519PointOps R, Ed25519PointOps Y, byte[] msgPrepared, BigInt q) {
        var m = concat(R.encode(true), Y.encode(true), nz(msgPrepared));
        var digest = Hash.sha512(m);

        return fromLittleEndian(digest).mod(q);
    }

    private static byte[] encodeCommitListDeterministic(List<ParticipantCommitment<Ed25519PointOps>> list) {
        if (list == null || list.isEmpty()) return new byte[0];

        var copy = new ArrayList<>(list);
        copy.sort(Comparator.comparingInt(ParticipantCommitment::idx));

        var chunks = new ArrayList<byte[]>(copy.size());
        for (var pc : copy) {
            chunks.add(concat(int32be(pc.idx()), pc.D().encode(true), pc.E().encode(true)));
        }
        return concat(chunks);
    }

    private static BigInt fromLittleEndian(byte[] le) {
        var be = le.clone();
        for (int i = 0, j = be.length - 1; i < j; i++, j--) {
            var t = be[i]; be[i] = be[j]; be[j] = t;
        }
        return new BigInt(1, be);
    }

    private static byte[] int32be(int x) {
        return ByteBuffer.allocate(4).putInt(x).array();
    }

    private static byte[] nz(byte[] b) {
        return b == null ? new byte[0] : b;
    }
}