package org.exploit.threshield.eddsa.tests;

import com.sun.jna.NativeLibrary;
import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Ed25519Provider;
import org.exploit.crypto.key.ed25519.Ed25519KeyPair;
import org.exploit.threshield.ed25519.Ed25519CurveParams;
import org.exploit.threshield.ed25519.Ed25519PointOps;
import org.exploit.threshield.frost.FrostClient;
import org.exploit.threshield.frost.context.FrostContext;
import org.exploit.threshield.frost.context.crypto.InMemoryCryptoContext;
import org.exploit.threshield.shamir.ECShamirKeySplitter;
import org.exploit.threshield.shamir.model.ECKeyShare;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.exploit.threshield.ed25519.rfc8032.Ed25519Clamp.toBigInt;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class ThresholdEdDSATests {
    private final String sessionId = "TEST";
    private final List<Integer> participants = List.of(1, 2, 3, 4);
    private final Map<Integer, FrostClient<Ed25519PointOps>> clients = new HashMap<>();
    private final Ed25519CurveParams curveParams = new Ed25519CurveParams();

    private final byte[] message = Hash.sha256("Hello World".getBytes());

    private final Ed25519KeyPair keyPair = (Ed25519KeyPair) Ed25519Provider.getInstance().generateKeyPair();

    static {
        NativeLibrary.addSearchPath("sodium", "/opt/homebrew/Cellar/libsodium/1.0.20/lib");
    }

    @BeforeEach
    public void init() {
        var splitter = new ECShamirKeySplitter<>(curveParams.getCurveOrder(), curveParams.getG(), 2, 4);
        var result = splitter.splitKey(toBigInt(keyPair.privateKey().encoded()));
        var reconstructed = splitter.recoverKey(result.shares());

        assertEquals(toBigInt(keyPair.privateKey().encoded()), reconstructed);

        for (var share : result.shares()) {
            var client = createClient(share);
            clients.put(share.index(), client);
        }
    }

    @Test
    public void testValidSignature() {
        var coordinator = clients.get(participants.get(0));

        prepareCommitments();
        aggregateZ(coordinator);

        var signature = coordinator.aggregator().computeSignature();
        assertTrue(Ed25519Provider.getInstance().verify(message, signature, keyPair.publicKey()));
    }

    private void prepareCommitments() {
        for (var client : clients.values()) {
            var idx = client.context().crypto().idx();
            var commitment = client.preProcessor().generateCommitment().toParticipant(idx);

            for (var i : participants) {
                if (i == idx)
                    continue;

                var clientJ = clients.get(i);
                clientJ.signature().storeCommitment(idx, commitment);
            }
        }
    }

    private void aggregateZ(FrostClient<Ed25519PointOps> coordinator) {
        for (var client : clients.values()) {
            coordinator.aggregator().storeZ(client.context().crypto().idx(), client.signature().computeZ());
        }
    }

    private FrostClient<Ed25519PointOps> createClient(ECKeyShare<Ed25519PointOps> share) {
        var publicKeyPoint = new Ed25519PointOps(keyPair.publicKey().encoded());

        var cryptoContext = new InMemoryCryptoContext<>(
                share.index(),
                participants,
                new Ed25519CurveParams(),
                share.share(),
                publicKeyPoint
        );

        var frostContext = FrostContext.newBuilder(Ed25519PointOps.class)
                .crypto(cryptoContext)
                .message(message)
                .build();

        return new FrostClient<>(sessionId, frostContext);
    }
}
