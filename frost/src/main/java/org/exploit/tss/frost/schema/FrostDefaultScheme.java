package org.exploit.tss.frost.schema;

import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.frost.hash.FrostHash;
import org.exploit.tss.frost.model.ContextOfR;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.signature.SchnorrSignature;
import org.exploit.tss.util.Endian;

import java.util.List;

public final class FrostDefaultScheme<P extends PointOps<P>> implements FrostScheme<P> {
    @Override
    public byte[] prepareMessage(byte[] msg) {
        return msg;
    }

    @Override
    public BigInt h1(int idx, byte[] msgPrepared, byte[] additionalContext, List<ParticipantCommitment<P>> B, BigInt q) {
        return FrostHash.H1(idx, msgPrepared, B, q);
    }

    @Override
    public ContextOfR<P> computeRCtx(P raw) {
        return new ContextOfR<>(raw.normalize(), false);
    }

    @Override
    public BigInt h2(ContextOfR<P> context, P groupY, byte[] msgPrepared, byte[] additionalContext, BigInt q) {
        return FrostHash.H2(context.canon(), groupY, msgPrepared, q);
    }

    @Override
    public SchnorrSignature buildSignature(ContextOfR<P> context, BigInt s, BigInt q) {
        var r33 = context.canon().encode(true);
        var sLe32 = Endian.toLittleEndian(s.mod(q), 32);
        return new SchnorrSignature(r33, sLe32);
    }
}