package org.exploit.tss.frost.aggregator;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.exception.IdentifiableAbortException;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.schema.FrostScheme;
import org.exploit.tss.frost.signature.FrostPartialSignatureClient;
import org.exploit.tss.signature.Signature;
import org.exploit.tss.util.Polynomials;
import org.exploit.tss.util.Sum;

@AllArgsConstructor
public class SignaturePartAggregator<P extends PointOps<P>> {
    private final FrostScheme<P> scheme;
    private final FrostContext<P> context;
    private final FrostPartialSignatureClient<P> client;

    private final Table<Integer, String, BigInt> parts = Tables.synchronizedTable(HashBasedTable.create());

    public void storeZ(int idx, String opId, BigInt z) {
        var q = context.crypto().curve().getCurveOrder();

        var commitment = context.commitment().getCommitment(idx, opId);
        var D_i = commitment.D();
        var E_i = commitment.E();

        var B = client.collectPeerCommitments(opId);

        var msgPrepared = scheme.prepareMessage(context.message(opId));

        var rho_i = scheme.h1(idx, msgPrepared, B, q);

        var rCtx = client.computeR(opId);

        @SuppressWarnings("unchecked")
        var Y = (P) context.crypto().Y();

        var c = scheme.h2(rCtx, Y, msgPrepared, q);

        var lambda_i = Polynomials.computeLagrangeCoefficient(idx, context.crypto().participants(), q);

        var g = context.crypto().curve().getG();
        var lhs = g.mul(z).normalize();

        var noncePoint = D_i.add(E_i.mul(rho_i)).normalize();
        if (rCtx.negateNonceTerm()) {
            noncePoint = noncePoint.negate().normalize();
        }

        var coeff = scheme.keyCoefficient(lambda_i, c, Y, q);
        var sharePoint = commitment.Y_i().mul(coeff).normalize();

        var rhs = noncePoint.add(sharePoint).normalize();

        if (!lhs.equals(rhs))
            throw new IdentifiableAbortException(idx, "Bad signature part");

        parts.put(idx, opId, z);
    }

    public Signature computeSignature(String opId) {
        var q = context.crypto().curve().getCurveOrder();

        var rCtx = client.computeR(opId);

        @SuppressWarnings("unchecked")
        var Y = (P) context.crypto().Y();

        var msgPrepared = scheme.prepareMessage(context.message(opId));
        var c = scheme.h2(rCtx, Y, msgPrepared, q);

        var zSum = Sum.modSum(BigInt.ZERO, q, parts.column(opId).values());
        var sFinal = scheme.finalizeS(zSum, c, Y, q);

        return scheme.buildSignature(rCtx, sFinal, q);
    }
}