package org.exploit.tss.frost.signature;

import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.exception.IdentifiableAbortException;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.exploit.tss.frost.constant.Domain.POP_DOMAIN;
import static org.exploit.tss.frost.hash.FrostHash.H1;
import static org.exploit.tss.frost.hash.FrostHash.H2;

public class FrostPartialSignatureClient<P extends PointOps<P>> {
    private final FrostContext<P> context;

    public FrostPartialSignatureClient(FrostContext<P> context) {
        this.context = context;
    }

    public void storeCommitment(int idx, String opId, ParticipantCommitment<P> com) {
        if (!verifyPoP(com))
            throw new IdentifiableAbortException(idx, "PoP failed");

        context.commitment().storePeerCommitment(idx, opId, com);
    }

    public PointOps<P> computeR(String opId) {
        var q = context.crypto().curve().getCurveOrder();
        var B = collectPeerCommitments(opId);

        var R = context.crypto().curve().getInfinity();

        for (var pc : B) {
            var rho_j = H1(pc.idx(), context.message(opId), B, q);
            var term = pc.D().add(pc.E().mul(rho_j));
            R = R.add(term);
        }

        return R.normalize();
    }

    public BigInt computeZ(String opId) {
        var q = context.crypto().curve().getCurveOrder();
        var idx = context.crypto().idx();
        var rho_i = H1(idx, context.message(opId), collectPeerCommitments(opId), q);

        var R = computeR(opId);
        var c = H2(R, context.crypto().Y(), context.message(opId), q);

        var pair = context.commitment().pair(opId);
        var d_i = pair.d();
        var e_i = pair.e();

        return context.crypto().useLagrangeShare(share -> d_i.add(e_i.multiplySec(rho_i)).add(share.multiplySec(c)).mod(q));
    }

    public List<ParticipantCommitment<P>> collectPeerCommitments(String opId) {
        var peers = context.commitment().getPeerCommitments(opId);

        List<ParticipantCommitment<P>> B = new ArrayList<>(peers);
        B.sort(Comparator.comparingInt(ParticipantCommitment::idx));

        return B;
    }

    private boolean verifyPoP(ParticipantCommitment<P> pc) {
        var curve = context.crypto().curve();
        var q = curve.getCurveOrder();

        var aad = context.additionalContext();

        var cBytes = Bytes.encode(POP_DOMAIN, aad, pc.Y_i().encode(true), pc.R().encode(true));
        var c = new BigInt(1, Hash.sha256(cBytes)).mod(q);

        var lhs = curve.getG().mul(pc.sigma()).normalize();
        var rhs = pc.R().add(pc.Y_i().mul(c)).normalize();

        return lhs.equals(rhs);
    }
}
