package org.exploit.tss.frost.signature;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.exception.IdentifiableAbortException;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.model.ContextOfR;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.frost.schema.FrostScheme;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.exploit.tss.frost.constant.Domain.POP_DOMAIN;

@AllArgsConstructor
public class FrostPartialSignatureClient<P extends PointOps<P>> {
    private final FrostContext<P> context;
    private final FrostScheme<P> scheme;

    public void storeCommitment(int idx, String opId, ParticipantCommitment<P> com) {
        if (!verifyPoP(com))
            throw new IdentifiableAbortException(idx, "PoP failed");

        context.commitment().storePeerCommitment(idx, opId, com);
    }

    public ContextOfR<P> computeR(String opId) {
        var q = context.crypto().curve().getCurveOrder();
        var B = collectPeerCommitments(opId);

        var msgPrepared = scheme.prepareMessage(context.message(opId));

        @SuppressWarnings("unchecked")
        var Rraw = (P) context.crypto().curve().getInfinity();

        for (var pc : B) {
            var rho_j = scheme.h1(pc.idx(), msgPrepared, B, q);
            var term = pc.D().add(pc.E().mul(rho_j));
            Rraw = Rraw.add(term);
        }

        Rraw = Rraw.normalize();

        return scheme.computeRCtx(Rraw);
    }

    public BigInt computeZ(String opId) {
        var q = context.crypto().curve().getCurveOrder();
        var idx = context.crypto().idx();

        var B = collectPeerCommitments(opId);
        var msgPrepared = scheme.prepareMessage(context.message(opId));

        var rho_i = scheme.h1(idx, msgPrepared, B, q);

        var rCtx = computeR(opId);

        @SuppressWarnings("unchecked")
        var Y = (P) context.crypto().Y();

        var c = scheme.h2(rCtx, Y, msgPrepared, q);

        var pair = context.commitment().pair(opId);
        var d_i = pair.d();
        var e_i = pair.e();

        var nonceTerm = d_i.add(e_i.multiplySec(rho_i)).mod(q);

        if (rCtx.negateNonceTerm())
            nonceTerm = q.subtract(nonceTerm).mod(q);

        var nonceTermFinal = nonceTerm;
        return context.crypto().useLagrangeShare(share ->
                nonceTermFinal.add(scheme.applyShareTerm(share, c, Y, q)).mod(q)
        );
    }

    public List<ParticipantCommitment<P>> collectPeerCommitments(String opId) {
        var peers = context.commitment().getPeerCommitments(opId);

        List<ParticipantCommitment<P>> B = new ArrayList<>(peers);
        B.sort(Comparator.comparingInt(ParticipantCommitment::idx));

        return B;
    }

    private boolean verifyPoP(ParticipantCommitment<P> pc) {
        var curve = context.crypto().curve();
        var q = curve.getCurveOrder();

        var aad = context.additionalContext();

        var cBytes = Bytes.encode(POP_DOMAIN, aad, pc.Y_i().encode(true), pc.R().encode(true));
        var c = new BigInt(1, Hash.sha256(cBytes)).mod(q);

        var lhs = curve.getG().mul(pc.sigma()).normalize();
        var rhs = pc.R().add(pc.Y_i().mul(c)).normalize();

        return lhs.equals(rhs);
    }
}
