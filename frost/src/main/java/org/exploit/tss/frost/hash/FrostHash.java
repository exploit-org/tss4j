package org.exploit.tss.frost.hash;

import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.frost.model.ParticipantCommitment;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import static org.exploit.tss.frost.constant.Domain.H1_DOMAIN;
import static org.exploit.tss.frost.constant.Domain.H2_DOMAIN;

public final class FrostHash {
    private FrostHash() {}

    public static <P extends PointOps<P>> BigInt H1(int idx, byte[] msg, byte[] additionalContext, List<ParticipantCommitment<P>> B, BigInt q) {
        var bytes = Bytes.encode(H1_DOMAIN, additionalContext, ByteBuffer.allocate(4).putInt(idx).array(), encodeCommitList(B), msg);

        return fromLittleEndian(Hash.sha512(bytes)).mod(q);
    }

    public static <P extends PointOps<P>> BigInt H2(PointOps<P> R, PointOps<P> Y, byte[] msg, byte[] additionalContext, BigInt q) {
        var bytes = Bytes.encode(H2_DOMAIN, additionalContext, R.encode(true), Y.encode(true), msg);

        return fromLittleEndian(Hash.sha512(bytes)).mod(q);
    }

    public static <P extends PointOps<P>> BigInt H1(int idx, byte[] msg, List<ParticipantCommitment<P>> B, BigInt q) {
        var bytes = Bytes.encode(ByteBuffer.allocate(4).putInt(idx).array(), encodeCommitList(B), msg);
        return fromLittleEndian(Hash.sha512(bytes)).mod(q);
    }

    public static <P extends PointOps<P>> BigInt H2(PointOps<P> R, PointOps<P> Y, byte[] msg, BigInt q) {
        var bytes = Bytes.concat(R.encode(true), Y.encode(true), msg);
        return fromLittleEndian(Hash.sha512(bytes)).mod(q);
    }

    private static <P extends PointOps<P>> byte[] encodeCommitList(List<ParticipantCommitment<P>> list) {
        List<byte[]> tlvs = new ArrayList<>(list.size());

        for (var pc : list) {
            tlvs.add(Bytes.encode(
                    ByteBuffer.allocate(4).putInt(pc.idx()).array(),
                    pc.D().encode(true),
                    pc.E().encode(true)
            ));
        }

        return Bytes.encode(tlvs.toArray(new byte[0][]));
    }

    private static BigInt fromLittleEndian(byte[] bytes) {
        for (int i = 0, j = bytes.length - 1; i < j; i++, j--) {
            var tmp = bytes[i];
            bytes[i] = bytes[j];
            bytes[j] = tmp;
        }
        return new BigInt(1, bytes);
    }
}