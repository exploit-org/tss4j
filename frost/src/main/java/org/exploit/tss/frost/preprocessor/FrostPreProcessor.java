package org.exploit.tss.frost.preprocessor;

import lombok.AllArgsConstructor;
import org.exploit.tss.util.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.frost.context.FrostContext;
import org.exploit.tss.frost.model.CommitmentPair;
import org.exploit.tss.util.ZKRandom;

@AllArgsConstructor
public class FrostPreProcessor<P extends PointOps<P>> {
    private final FrostContext<P> context;

    public CommitmentPair<P> generateCommitment(String opId) {
        var ecSpec = context.crypto().curve();

        var d = new BigInt(ecSpec.getCurveOrder().bitLength(), ZKRandom.getRandom()).mod(ecSpec.getCurveOrder());
        var e = new BigInt(ecSpec.getCurveOrder().bitLength(), ZKRandom.getRandom()).mod(ecSpec.getCurveOrder());

        var D = ecSpec.getG().mul(d).normalize();
        var E = ecSpec.getG().mul(e).normalize();

        return context.crypto().useSki(ski -> {
            var Y_i = context.crypto().curve().getG().mul(ski).normalize();
            var c = new BigInt(1, Hash.sha256(Y_i.encode(true))).mod(ecSpec.getCurveOrder());
            var r = new BigInt(ecSpec.getCurveOrder().bitLength(), ZKRandom.getRandom()).mod(ecSpec.getCurveOrder());
            var R = ecSpec.getG().mul(r).normalize();
            var sigma = r.add(c.multiplySec(ski)).mod(ecSpec.getCurveOrder());

            var pair = new CommitmentPair<>(d, e, D, E, Y_i, R, sigma);
            context.commitment().setCommitmentPair(opId, pair);
            context.commitment().storePeerCommitment(context.crypto().idx(), opId, pair.toParticipant(context.crypto().idx()));

            return pair;
        });
    }
}
