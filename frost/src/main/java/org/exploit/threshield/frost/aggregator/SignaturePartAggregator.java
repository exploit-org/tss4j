package org.exploit.threshield.frost.aggregator;

import lombok.AllArgsConstructor;
import org.exploit.crypto.signature.SchnorrSignature;
import org.exploit.threshield.curve.PointOps;
import org.exploit.threshield.frost.context.FrostContext;
import org.exploit.threshield.frost.signature.FrostPartialSignatureClient;
import org.exploit.threshield.exception.IdentifiableAbortException;
import org.exploit.threshield.frost.hash.FrostHash;
import org.exploit.threshield.util.Polynomials;
import org.exploit.threshield.util.Sum;

import java.math.BigInteger;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static org.exploit.threshield.util.Endian.toLittleEndian;

@AllArgsConstructor
public class SignaturePartAggregator<P extends PointOps<P>> {
    private final FrostContext<P> context;
    private final FrostPartialSignatureClient<P> client;

    private final Map<Integer, BigInteger> parts = new ConcurrentHashMap<>();

    public void storeZ(int idx, BigInteger z) {
        var q = context.crypto().curve().getCurveOrder();

        var commitment = context.commitment().getCommitment(idx);
        var D_i = commitment.D();
        var E_i = commitment.E();

        var message = context.message();

        var B = client.collectPeerCommitments();

        var rho_i = FrostHash.H1(idx, message, B, q);

        var R = client.computeR();
        var Y = context.crypto().Y();

        var c = FrostHash.H2(R, Y, message, q);

        var lambda_i = Polynomials.computeLagrangeCoefficient(idx, context.crypto().participants(), q);

        var g = context.crypto().curve().getG();
        var lhs = g.mul(z).normalize();

        var E_i_rho_i = E_i.mul(rho_i).normalize();
        var Y_i_lambda_c = commitment.Y_i().mul(lambda_i.multiply(c).mod(q)).normalize();
        var rhs = D_i.add(E_i_rho_i).add(Y_i_lambda_c).normalize();

        if (!lhs.equals(rhs))
            throw new IdentifiableAbortException(idx, "Bad signature part");

        parts.put(idx, z);
    }

    public SchnorrSignature computeSignature() {
        var r = client.computeR();
        var zSum = Sum.modSum(BigInteger.ZERO, context.crypto().curve().getCurveOrder(), parts.values());
        var s = toLittleEndian(zSum, 32);

        return new SchnorrSignature(r.encode(true), s);
    }
}
