package org.exploit.threshield.frost.aggregator;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import lombok.AllArgsConstructor;
import org.exploit.crypto.signature.SchnorrSignature;
import org.exploit.gmp.BigInt;
import org.exploit.threshield.curve.PointOps;
import org.exploit.threshield.exception.IdentifiableAbortException;
import org.exploit.threshield.frost.context.FrostContext;
import org.exploit.threshield.frost.hash.FrostHash;
import org.exploit.threshield.frost.signature.FrostPartialSignatureClient;
import org.exploit.threshield.util.Polynomials;
import org.exploit.threshield.util.Sum;

import static org.exploit.threshield.util.Endian.toLittleEndian;

@AllArgsConstructor
public class SignaturePartAggregator<P extends PointOps<P>> {
    private final FrostContext<P> context;
    private final FrostPartialSignatureClient<P> client;

    private final Table<Integer, String, BigInt> parts = Tables.synchronizedTable(HashBasedTable.create());

    public void storeZ(int idx, String opId, BigInt z) {
        var q = context.crypto().curve().getCurveOrder();

        var commitment = context.commitment().getCommitment(idx, opId);
        var D_i = commitment.D();
        var E_i = commitment.E();

        var message = context.message(opId);

        var B = client.collectPeerCommitments(opId);

        var rho_i = FrostHash.H1(idx, message, B, q);

        var R = client.computeR(opId);
        var Y = context.crypto().Y();

        var c = FrostHash.H2(R, Y, message, q);

        var lambda_i = Polynomials.computeLagrangeCoefficient(idx, context.crypto().participants(), q);

        var g = context.crypto().curve().getG();
        var lhs = g.mul(z).normalize();

        var E_i_rho_i = E_i.mul(rho_i).normalize();
        var Y_i_lambda_c = commitment.Y_i().mul(lambda_i.multiply(c).mod(q)).normalize();
        var rhs = D_i.add(E_i_rho_i).add(Y_i_lambda_c).normalize();

        if (!lhs.equals(rhs))
            throw new IdentifiableAbortException(idx, "Bad signature part");

        parts.put(idx, opId, z);
    }

    public SchnorrSignature computeSignature(String opId) {
        var r = client.computeR(opId);
        var zSum = Sum.modSum(BigInt.ZERO, context.crypto().curve().getCurveOrder(), parts.column(opId).values());
        var s = toLittleEndian(zSum, 32);

        return new SchnorrSignature(r.encode(true), s);
    }
}
