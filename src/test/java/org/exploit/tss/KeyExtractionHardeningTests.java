package org.exploit.tss;

import org.exploit.gmp.BigInt;
import org.exploit.tss.mta.MtAProtocol;
import org.exploit.tss.pallier.Paillier;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.proof.model.NoSmallFactorProof;
import org.exploit.tss.proof.model.PaillierRangeProof;
import org.exploit.tss.proof.model.PaillierRespondentProof;
import org.exploit.tss.proof.model.ZKSetup;
import org.exploit.tss.proof.model.context.PaillierRangeProofContext;
import org.exploit.tss.proof.model.context.PaillierRespondentProofContext;
import org.exploit.tss.proof.model.witness.PaillierRangeEncryptionWitness;
import org.exploit.tss.proof.model.witness.PaillierRespondentEncryptionWitness;
import org.exploit.tss.proof.paillier.*;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;


public class KeyExtractionHardeningTests {
    @BeforeEach
    public void setUp() {
        TSS.loadLibraries();
    }

    @Test
    public void biPrimeRejectsMismatchedPublicKeyN() {
        var honest = Paillier.generateKeyPair(2048);
        var gen = new BiPrimeProofGenerator();

        var proof = gen.createProof(honest.privateKey(), "ctx".getBytes());
        var otherPk = Paillier.generateKeyPair(2048).publicKey();

        var val = new BiPrimeProofValidator();
        assertFalse(val.verifyProof(proof, otherPk, "ctx".getBytes()), "BiPrime must fail if proof.N does not match pk.n");
    }

    @Test
    public void biPrimeGeneratorRejectsNonBlumModulus() {
        var p = BigInt.valueOf(3);
        var q = BigInt.valueOf(5);

        var lambda = p.subtract(BigInt.ONE).multiplySec(q.subtract(BigInt.ONE)).divide(p.subtract(BigInt.ONE).gcd(q.subtract(BigInt.ONE)));
        var n = p.multiply(q);

        var mu = lambda.modInverseSec(n);
        var invalidPriv = new PaillierPrivateKey(lambda, mu, p, q);
        var gen = new BiPrimeProofGenerator();

        assertThrows(IllegalArgumentException.class, () -> gen.createProof(invalidPriv, new byte[0]), "Generator must reject non-Blum moduli");
    }

    @Test
    public void rejectSmallNvsQInMtA() {
        var small = new Paillier(Paillier.generateKeyPair(1024));
        var q = BigInt.valueOf(2).pow(240);

        assertThrows(IllegalArgumentException.class, () -> new MtAProtocol(small, q), "Paillier modulus must satisfy N >= q^8");
    }

    @Test
    public void rangeProofContextBinding() {
        var pair = Paillier.generateKeyPair(2048);
        var pk = pair.publicKey();

        var zk = ZKSetup.generate(1024);
        var q = BigInt.valueOf(2).pow(256);
        var m = BigInt.valueOf(12345);

        var enc = new Paillier(pair).encryptWithRandomness(m);

        var wit = new PaillierRangeEncryptionWitness(m, enc.r(), enc.c(), pk, zk, q);
        var proof = new PaillierRangeProofGenerator().createProof(wit, "A".getBytes());

        var ctxA = new PaillierRangeProofContext(enc.c(), q, zk, "A".getBytes());
        var ctxB = new PaillierRangeProofContext(enc.c(), q, zk, "B".getBytes());

        var val = new PaillierRangeProofValidator();

        assertTrue(val.verifyProof(proof, pk, ctxA), "Valid range proof must be accepted");
        assertFalse(val.verifyProof(proof, pk, ctxB), "Changing context must invalidate the proof");
    }

    @Test
    public void respondentProofContextBinding() {
        var pair = Paillier.generateKeyPair(2048);
        var pk = pair.publicKey();

        var zk = ZKSetup.generate(1024);
        var q = BigInt.valueOf(2).pow(256);

        var n = pk.n();
        var nsq = pk.nsquare();

        var b = BigInt.valueOf(7);
        var y = BigInt.valueOf(9);

        BigInt r_i, r_j;
        do {
            r_i = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r_i.compareTo(n) >= 0 || !r_i.gcd(n).equals(BigInt.ONE));

        do {
            r_j = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r_j.compareTo(n) >= 0 || !r_j.gcd(n).equals(BigInt.ONE));

        var gPowB = BigInt.ONE.add(n.multiplySec(b));
        var gPowY = BigInt.ONE.add(n.multiplySec(y));

        var c_i = gPowB.multiplySec(r_i.modPowSec(n, nsq)).mod(nsq);
        var c_j = c_i.modPowSec(b, nsq).multiplySec(gPowY).multiplySec(r_j.modPowSec(n, nsq)).mod(nsq);

        var wit = new PaillierRespondentEncryptionWitness(b, y, c_i, c_j, r_j, pk, zk, q);
        var proof = new PaillierRespondentProofGenerator().createProof(wit, "A".getBytes());

        var ctxA = new PaillierRespondentProofContext(c_i, c_j, q, zk, "A".getBytes());
        var ctxB = new PaillierRespondentProofContext(c_i, c_j, q, zk, "B".getBytes());

        var val = new PaillierRespondentProofValidator();

        assertTrue(val.verifyProof(proof, pk, ctxA), "Valid respondent proof must be accepted");
        assertFalse(val.verifyProof(proof, pk, ctxB), "Changing context must invalidate the proof");
    }

    @Test
    public void rangeProofFailsIfCiphertextTampered() {
        var pair = Paillier.generateKeyPair(2048);
        var pk = pair.publicKey();

        var zk = ZKSetup.generate(1024);

        var q = BigInt.valueOf(2).pow(256);
        var m = BigInt.valueOf(42);

        var enc = new Paillier(pair).encryptWithRandomness(m);
        var wit = new PaillierRangeEncryptionWitness(m, enc.r(), enc.c(), pk, zk, q);

        var proof = new PaillierRangeProofGenerator().createProof(wit, "ctx".getBytes());
        var tamperedC = enc.c().multiply(pk.n()).mod(pk.nsquare());

        var ctx = new PaillierRangeProofContext(tamperedC, q, zk, "ctx".getBytes());
        var val = new PaillierRangeProofValidator();

        assertFalse(val.verifyProof(proof, pk, ctx), "Range proof must bind to the exact ciphertext");
    }

    @Test
    public void respondentProofFailsIfCjTampered() {
        var pair = Paillier.generateKeyPair(2048);
        var pk = pair.publicKey();

        var zk = ZKSetup.generate(1024);
        var q = BigInt.valueOf(2).pow(256);

        var n = pk.n();
        var nsq = pk.nsquare();

        var b = BigInt.valueOf(5);
        var y = BigInt.valueOf(6);

        BigInt r_i, r_j;
        do {
            r_i = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r_i.compareTo(n) >= 0 || !r_i.gcd(n).equals(BigInt.ONE));

        do {
            r_j = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r_j.compareTo(n) >= 0 || !r_j.gcd(n).equals(BigInt.ONE));

        var gPowB = BigInt.ONE.add(n.multiplySec(b));
        var gPowY = BigInt.ONE.add(n.multiplySec(y));

        var c_i = gPowB.multiplySec(r_i.modPowSec(n, nsq)).mod(nsq);
        var c_j = c_i.modPowSec(b, nsq).multiplySec(gPowY).multiplySec(r_j.modPowSec(n, nsq)).mod(nsq);

        var wit = new PaillierRespondentEncryptionWitness(b, y, c_i, c_j, r_j, pk, zk, q);
        var proof = new PaillierRespondentProofGenerator().createProof(wit, "ctx".getBytes());

        var tamperedCj = c_j.multiply(pk.n()).mod(nsq);
        var ctx = new PaillierRespondentProofContext(c_i, tamperedCj, q, zk, "ctx".getBytes());
        var val = new PaillierRespondentProofValidator();

        assertFalse(val.verifyProof(proof, pk, ctx), "Respondent proof must bind to the exact c_j");
    }

    @Test
    public void respondentRejectsNonUnitCi() {
        var pair = Paillier.generateKeyPair(2048);
        var pk = pair.publicKey();

        var zk = ZKSetup.generate(1024);
        var q = BigInt.valueOf(2).pow(256);

        var n = pk.n();
        var nsq = pk.nsquare();

        var c_i = n.mod(nsq);
        var c_j = c_i;

        var ctx = new PaillierRespondentProofContext(c_i, c_j, q, zk, "ctx".getBytes());
        var val = new PaillierRespondentProofValidator();

        var bogus = new PaillierRespondentProof(new byte[]{1}, new byte[]{1}, new byte[]{1}, new byte[]{1}, new byte[]{1}, new byte[]{1}, BigInt.ZERO, BigInt.ZERO, BigInt.ZERO, BigInt.ZERO);
        assertFalse(val.verifyProof(bogus, pk, ctx), "c_i with gcd(c_i, n) != 1 must be rejected");
    }

    @Test
    public void noSmallFactorRejectsSmallKeyAndBadCommitments() {
        var zk = ZKSetup.generate(1024);
        var small = Paillier.generateKeyPair(1024);

        var gen = new NoSmallFactorProofGenerator(zk);
        var proof = gen.createProof(small.privateKey(), "ctx".getBytes());

        var val = new NoSmallFactorProofValidator(zk);
        assertFalse(val.verifyProof(proof, small.publicKey(), "ctx".getBytes()), "Paillier keys smaller than 2048 bits must be rejected");
        var forgedA = new byte[]{0x00};

        var forged = new NoSmallFactorProof(proof.P(), proof.Q(), forgedA, proof.B(), proof.T(), proof.z1(), proof.z2(), proof.w1(), proof.w2(), proof.v());
        assertFalse(val.verifyProof(forged, small.publicKey(), "ctx".getBytes()), "Commitments not coprime to hatN must be rejected");
    }

    @Test
    public void respondentRejectsS1AndT1OutOfRange() {
        var q = BigInt.valueOf(101);
        var pair = Paillier.generateKeyPair(512);

        var pk = pair.publicKey();
        var zk = ZKSetup.generate(512);

        var n = pk.n();
        var nsq = pk.nsquare();

        var b = BigInt.valueOf(3);
        var y = BigInt.valueOf(7);

        BigInt r_i, r_j;
        do {
            r_i = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r_i.compareTo(n) >= 0 || !r_i.gcd(n).equals(BigInt.ONE));

        do {
            r_j = new BigInt(n.bitLength(), ZKRandom.getRandom()); }
        while (r_j.compareTo(n) >= 0 || !r_j.gcd(n).equals(BigInt.ONE));

        var gPowB = BigInt.ONE.add(n.multiplySec(b));
        var gPowY = BigInt.ONE.add(n.multiplySec(y));

        var c_i = gPowB.multiplySec(r_i.modPowSec(n, nsq)).mod(nsq);
        var c_j = c_i.modPowSec(b, nsq).multiplySec(gPowY).multiplySec(r_j.modPowSec(n, nsq)).mod(nsq);

        var wit = new PaillierRespondentEncryptionWitness(b, y, c_i, c_j, r_j, pk, zk, q);
        var proof = new PaillierRespondentProofGenerator().createProof(wit, "ctx".getBytes());

        var ctx = new PaillierRespondentProofContext(c_i, c_j, q, zk, "ctx".getBytes());
        var val = new PaillierRespondentProofValidator();

        var s1TooBig = q.pow(3).add(BigInt.ONE);

        var badS1 = new PaillierRespondentProof(proof.z(), proof.zPrime(), proof.t(), proof.v(), proof.w(), proof.s(), s1TooBig, proof.s2(), proof.t1(), proof.t2());
        assertFalse(val.verifyProof(badS1, pk, ctx), "s1 must be in Z_{q^3}");

        var t1TooBig = q.pow(7).add(BigInt.ONE);
        var badT1 = new PaillierRespondentProof(proof.z(), proof.zPrime(), proof.t(), proof.v(), proof.w(), proof.s(), proof.s1(), proof.s2(), t1TooBig, proof.t2());
        assertFalse(val.verifyProof(badT1, pk, ctx), "t1 must be in Z_{q^7}");
    }

    @Test
    public void rangeProofAcceptsValidAndRejectsOutOfRangeS1() {
        var q = BigInt.valueOf(101);
        var pair = Paillier.generateKeyPair(512);

        var pk = pair.publicKey();
        var zk = ZKSetup.generate(512);

        var m = BigInt.valueOf(17);
        var r = BigInt.valueOf(5);

        var n = pk.n();
        var nsq = pk.nsquare();

        var gm = BigInt.ONE.add(n.multiplySec(m));
        var rn = r.modPowSec(n, nsq);
        var c = gm.multiplySec(rn).mod(nsq);

        var wit = new PaillierRangeEncryptionWitness(m, r, c, pk, zk, q);
        var proof = new PaillierRangeProofGenerator().createProof(wit, new byte[]{10});

        var ctx = new PaillierRangeProofContext(c, q, zk, new byte[]{10});
        var val = new PaillierRangeProofValidator();

        assertTrue(val.verifyProof(proof, pk, ctx), "Valid range proof must be accepted");

        var s1TooBig = q.pow(3).add(BigInt.ONE);
        var bad = new PaillierRangeProof(proof.z(), proof.u(), proof.w(), proof.s(), s1TooBig, proof.s2());

        assertFalse(val.verifyProof(bad, pk, ctx), "s1 must be in Z_{q^3}");
    }
}