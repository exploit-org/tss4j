package org.exploit.tss;

import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.Paillier;
import org.exploit.tss.proof.model.BiPrimeBlumProof;
import org.exploit.tss.proof.paillier.BiPrimeProofGenerator;
import org.exploit.tss.proof.paillier.BiPrimeProofValidator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class BiPrimeProofTests {
    @BeforeEach
    void setUp() {
        TSS.loadLibraries();
    }

    @RepeatedTest(64)
    void proof_verifies_forValidBlumModulus() {
        var nBits = 3072;
        var kp = Paillier.generateKeyPair(nBits);
        var gen = new BiPrimeProofGenerator();
        var ctx = "TKeeper:BiPrime:v1:test".getBytes();

        var proof = gen.createProof(kp.privateKey(), ctx);
        var ver = new BiPrimeProofValidator();

        assertTrue(ver.verifyProof(proof, kp.publicKey(), ctx));
    }

    @RepeatedTest(64)
    void proof_rejects_withDifferentContext() {
        var nBits = 1024;
        var kp = Paillier.generateKeyPair(nBits);
        var gen = new BiPrimeProofGenerator();

        var ctx = "ctx-A".getBytes();
        var ctx2 = "ctx-B".getBytes();

        var proof = gen.createProof(kp.privateKey(), ctx);
        var ver = new BiPrimeProofValidator();

        assertTrue(ver.verifyProof(proof, kp.publicKey(), ctx), "baseline verify");
        assertFalse(ver.verifyProof(proof, kp.publicKey(), ctx2), "must fail on different context");
    }

    @Test
    void proof_rejects_withDifferentModulus() {
        var nBits = 1024;
        var kp1 = Paillier.generateKeyPair(nBits);
        var kp2 = Paillier.generateKeyPair(nBits);

        var gen = new BiPrimeProofGenerator();
        var ctx = "ctx".getBytes();

        var proof = gen.createProof(kp1.privateKey(), ctx);
        var ver = new BiPrimeProofValidator();

        assertTrue(ver.verifyProof(proof, kp1.publicKey(), ctx), "baseline verify");
        assertFalse(ver.verifyProof(proof, kp2.publicKey(), ctx), "must bind to N");
    }

    @Test
    void proof_rejects_whenTampered_bitsOrWitness() {
        var nBits = 1024;
        var kp = Paillier.generateKeyPair(nBits);
        var gen = new BiPrimeProofGenerator();
        var ctx = "tamper".getBytes();

        var proof = gen.createProof(kp.privateKey(), ctx);
        var ver = new BiPrimeProofValidator();

        assertTrue(ver.verifyProof(proof, kp.publicKey(), ctx), "baseline verify");

        var a = proof.aBits().clone();
        a[0] ^= 0x01;
        var tamperedA = new BiPrimeBlumProof(
                proof.N(), proof.w(), proof.sigmas(), proof.xs(),
                a, proof.bBits(), proof.zs(), proof.sfRounds(), proof.blumRounds());
        assertFalse(ver.verifyProof(tamperedA, kp.publicKey(), ctx), "tampered aBits must fail");

        List<BigInt> xs = new ArrayList<>(proof.xs());
        xs.set(0, xs.get(0).add(BigInt.ONE));
        var tamperedX = new BiPrimeBlumProof(
                proof.N(), proof.w(), proof.sigmas(), List.copyOf(xs),
                proof.aBits(), proof.bBits(), proof.zs(), proof.sfRounds(), proof.blumRounds());
        assertFalse(ver.verifyProof(tamperedX, kp.publicKey(), ctx), "tampered x must fail");

        var tamperedW = new BiPrimeBlumProof(
                proof.N(), proof.w().add(BigInt.ONE), proof.sigmas(), proof.xs(),
                proof.aBits(), proof.bBits(), proof.zs(), proof.sfRounds(), proof.blumRounds());
        assertFalse(ver.verifyProof(tamperedW, kp.publicKey(), ctx), "tampered w must fail");
    }
}
