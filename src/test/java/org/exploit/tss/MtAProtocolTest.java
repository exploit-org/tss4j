package org.exploit.tss;

import com.sun.jna.NativeLibrary;
import org.exploit.gmp.BigInt;
import org.exploit.tss.mta.MtAProtocol;
import org.exploit.tss.mta.model.MtAInitiatorMessage;
import org.exploit.tss.mta.model.MtAResult;
import org.exploit.tss.pallier.Paillier;
import org.exploit.tss.pallier.key.PaillierKeyPair;
import org.exploit.tss.proof.model.PaillierRangeProof;
import org.exploit.tss.proof.model.PaillierRespondentProof;
import org.exploit.tss.proof.model.ZKSetup;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class MtAProtocolTest {
    private PaillierKeyPair keyPair;
    private Paillier paillier;
    private MtAProtocol mta;
    
    private BigInt CURVE_ORDER;

    @BeforeEach
    public void setUp() {
        NativeLibrary.addSearchPath("gmp", "/opt/homebrew/Cellar/gmp/6.3.0/lib");

        CURVE_ORDER = new BigInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);

        keyPair = Paillier.generateKeyPair(3072);
        paillier = new Paillier(keyPair);
        mta = new MtAProtocol(paillier, CURVE_ORDER);
    }

    @Test
    public void testMtAProtocol() {
        var a_i = BigInt.valueOf(5);
        var b_j = BigInt.valueOf(3);

        var c_i = mta.encryptA(a_i);
        var result = mta.computeCjWithY(paillier.publicKey(), c_i, b_j);

        var c_j = result.c_j();
        var y = result.y();

        var alpha_i = mta.decryptCj(c_j);
        var beta_j = mta.computeBeta(y);

        var product = a_i.multiply(b_j).mod(CURVE_ORDER);
        var sum = alpha_i.add(beta_j).mod(CURVE_ORDER);

        assertEquals(product, sum);
    }

    @Test
    public void testEncryptAInvalidInput() {
        assertThrows(IllegalArgumentException.class, () -> mta.encryptA(null));
        assertThrows(IllegalArgumentException.class, () -> mta.encryptA(BigInt.valueOf(-1)));
        assertThrows(IllegalArgumentException.class, () -> mta.encryptA(paillier.publicKey().n()));
    }

    @Test
    public void testDecryptCjNullInput() {
        assertThrows(IllegalArgumentException.class, () -> mta.decryptCj(null));
    }

    @Test
    public void testComputeBetaNullInput() {
        assertThrows(IllegalArgumentException.class, () -> mta.computeBeta(null));
    }

    @Test
    public void testInitiatorProof() {
        var q = BigInt.valueOf(1000000007);
        var mta = new MtAProtocol(paillier, q);

        var zkSetup = ZKSetup.generate(2048);
        var a_i = BigInt.valueOf(5);
        var context = "test_initiator".getBytes();

        var initiatorMessage = mta.generateInitiatorMessage(a_i, zkSetup, context);

        assertTrue(mta.verifyInitiatorProof(initiatorMessage, paillier.publicKey(), zkSetup, context));

        var fakeProof = new PaillierRangeProof(
                initiatorMessage.proof().z(),
                initiatorMessage.proof().u(),
                initiatorMessage.proof().w(),
                initiatorMessage.proof().s(),
                initiatorMessage.proof().s1().add(BigInt.ONE),
                initiatorMessage.proof().s2()
        );
        var fakeMessage = new MtAInitiatorMessage(initiatorMessage.cA(), fakeProof);

        assertFalse(mta.verifyInitiatorProof(fakeMessage, paillier.publicKey(), zkSetup, context));
    }

    @Test
    public void testRespondentProof() {
        var q = BigInt.valueOf(1000000007);
        var mta = new MtAProtocol(paillier, q);
        var zkSetup = ZKSetup.generate(2048);
        var a_i = BigInt.valueOf(5);
        var b_j = BigInt.valueOf(3);
        var context = "test_respondent".getBytes();

        var c_i = mta.encryptA(a_i);

        var result = mta.computeCjWithY(paillier.publicKey(), c_i, b_j, zkSetup, context);

        assertTrue(mta.verifyRespondentProof(result, c_i, paillier.publicKey(), zkSetup, context));

        var fakeResult = getFakeResult(result);

        assertFalse(mta.verifyRespondentProof(fakeResult, c_i, paillier.publicKey(), zkSetup, context));
    }

    private static MtAResult getFakeResult(MtAResult result) {
        var fakeProof = new PaillierRespondentProof(
                result.proof().z(),
                result.proof().zPrime(),
                result.proof().t(),
                result.proof().v(),
                result.proof().w(),
                result.proof().s(),
                result.proof().s1().add(BigInt.ONE),
                result.proof().s2(),
                result.proof().t1(),
                result.proof().t2()
        );

        return new MtAResult(result.c_j(), result.y(), BigInt.ONE, fakeProof);
    }
}