package org.exploit.tss;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.proof.dleq.DleqProofGenerator;
import org.exploit.tss.proof.dleq.DleqProofValidator;
import org.exploit.tss.proof.model.DleqProof;
import org.exploit.tss.proof.model.context.DleqContext;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class DleqProofTest {
    private Secp256k1CurveParams CURVE;
    private BigInt Q;
    private Secp256k1PointOps G;

    private DleqProofGenerator<Secp256k1PointOps> generator;
    private DleqProofValidator<Secp256k1PointOps> validator;

    @BeforeEach
    void prepare() {
        TSS.loadLibraries();

        CURVE = new Secp256k1CurveParams();
        Q = CURVE.getCurveOrder();
        G = CURVE.getG();

        generator = new DleqProofGenerator<>(Q, G);
        validator = new DleqProofValidator<>(Q, G);
    }

    @RepeatedTest(64)
    void proofVerifies() {
        var xi = randomScalar();
        var k = randomScalar();

        var R = G.mul(k);
        var Y = G.mul(xi);
        var d = R.mul(xi);

        var ctx = new DleqContext<>(R, Y, d);
        var proof = generator.createProof(xi, ctx);

        assertTrue(validator.verifyProof(proof, ctx, null));
    }

    @Test
    void tamperRBreaks() {
        var xi = randomScalar();
        var ctx = buildContext(xi);
        var proof = generator.createProof(xi, ctx);
        var bad = new DleqProof<>(proof.getA1(), proof.getA2(),
                proof.getR().add(BigInt.ONE).mod(Q));

        assertFalse(validator.verifyProof(bad, ctx, null));
    }

    @Test
    void tamperA1Breaks() {
        var xi = randomScalar();
        var ctx = buildContext(xi);
        var proof = generator.createProof(xi, ctx);
        var bad = new DleqProof<>(proof.getA1().add(G), proof.getA2(), proof.getR());

        assertFalse(validator.verifyProof(bad, ctx, null));
    }

    @Test
    void tamperA2Breaks() {
        var xi = randomScalar();
        var ctx = buildContext(xi);
        var proof = generator.createProof(xi, ctx);
        var bad = new DleqProof<>(proof.getA1(), proof.getA2().add(G), proof.getR());

        assertFalse(validator.verifyProof(bad, ctx, null));
    }

    @Test
    void edge_xi1_k1() {
        runEdgeCase(BigInt.ONE, BigInt.ONE);
    }

    @Test
    void edge_xi1_kMinus1() {
        runEdgeCase(BigInt.ONE, Q.subtract(BigInt.ONE));
    }

    @Test
    void edge_xiMinus1_k1() {
        runEdgeCase(Q.subtract(BigInt.ONE), BigInt.ONE);
    }

    @Test
    void edge_xiMinus1_kMinus1() {
        runEdgeCase(Q.subtract(BigInt.ONE), Q.subtract(BigInt.ONE));
    }

    private void runEdgeCase(BigInt xi, BigInt k) {
        var R = G.mul(k);
        var Y = G.mul(xi);
        var d = R.mul(xi);

        var ctx = new DleqContext<>(R, Y, d);
        var proof = generator.createProof(xi, ctx);

        assertTrue(validator.verifyProof(proof, ctx, null));
    }

    private DleqContext<Secp256k1PointOps> buildContext(BigInt xi) {
        var k = randomScalar();

        var R = G.mul(k);
        var Y = G.mul(xi);
        var d = R.mul(xi);
        return new DleqContext<>(R, Y, d);
    }

    private BigInt randomScalar() {
        BigInt s;
        do {
            s = new BigInt(Q.bitLength(), ZKRandom.getRandom()).mod(Q);
        } while (s.signum() == 0);
        return s;
    }
}
