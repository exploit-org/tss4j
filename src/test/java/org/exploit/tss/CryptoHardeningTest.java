package org.exploit.tss;

import com.sun.jna.NativeLibrary;
import org.exploit.tss.util.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.gmp.util.PrimeNumberGenerator;
import org.exploit.tss.mta.MtAProtocol;
import org.exploit.tss.pallier.Paillier;
import org.exploit.tss.pallier.key.PaillierKeyPair;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.model.PoKNProof;
import org.exploit.tss.proof.model.ZKSetup;
import org.exploit.tss.proof.paillier.PoKNProofGenerator;
import org.exploit.tss.proof.paillier.PoKNProofValidator;
import org.exploit.tss.util.BigIntUtils;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

class CryptoHardeningTest {
    private static final BigInt CURVE_ORDER;

    private PaillierKeyPair kp;
    private Paillier paillier;
    private final PoKNProofGenerator pokGen = new PoKNProofGenerator();
    private final PoKNProofValidator pokVal = new PoKNProofValidator();

    static {
        TSS.loadLibraries();
        CURVE_ORDER = new BigInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",16);
    }

    @BeforeEach
    void init() {
        kp = Paillier.generateKeyPair(3072);
        paillier  = new Paillier(kp);
        NativeLibrary.addSearchPath("gmp", "/opt/homebrew/Cellar/gmp/6.3.0/lib");
    }

    @Test
    void pokN_validProof_passes() {
        var ctx = "session42".getBytes();
        var proof = pokGen.createProof(kp.privateKey(), ctx);

        assertTrue(pokVal.verifyProof(proof, kp.publicKey(), ctx),
                   "PoK(N) must verify");
    }

    @Test
    void pokN_tamperedProof_fails() {
        var ctx = "any".getBytes();
        var good = pokGen.createProof(kp.privateKey(), ctx);

        var badCommit = good.commit().clone();
        badCommit[0] ^= 0x01;
        var fake = new PoKNProof(badCommit, good.s());

        assertFalse(pokVal.verifyProof(fake, kp.publicKey(), ctx),
                    "Corrupted PoK(N) must fail");
    }

    @Test
    void pokN_smallFactor_rejectedEarly() {
        var p = BigInt.valueOf(3);
        var q = PrimeNumberGenerator.generate(1535);
        var n = p.multiply(q);
        var badPk = new PaillierPublicKey(n, n.add(BigInt.ONE), n.bitLength());

        var proof = new PoKNProof(new byte[]{1}, new byte[]{1});
        assertFalse(pokVal.verifyProof(proof, badPk, new byte[0]),
                    "Modulus with small factor must fail");
    }

    @Test
    void randomZnStar_coprime() {
        var n = kp.publicKey().nsquare();
        var rnd = BigIntUtils.randomZnStar(n, ZKRandom.getRandom());
        assertEquals(BigInt.ONE, rnd.gcd(n),
                     "randomZnStar must return element in Z_n*");
    }

    @Test
    void bytesEncode_noAmbiguity() {
        var x1 = "ab$".getBytes();
        var x2 = "cd".getBytes();

        var y1 = "ab".getBytes();
        var y2 = "$cd".getBytes();

        var h1 = Hash.sha256(Bytes.encode(x1,x2));
        var h2 = Hash.sha256(Bytes.encode(y1,y2));

        assertFalse(Arrays.equals(h1,h2),
                    "Length-prefixed encoding must differ for ambiguous splits");
    }

    @Test
    void initiatorMessage_fullVerification() {
        var proto = new MtAProtocol(paillier, CURVE_ORDER);
        var zk = ZKSetup.generate(2048);
        var ctx = "init_test".getBytes();

        var a_i = BigInt.valueOf(42);
        var msg = proto.generateInitiatorMessage(a_i, zk, ctx);

        assertTrue(proto.verifyInitiatorRangeProof(msg, paillier.publicKey(), zk, ctx));
        assertTrue(proto.verifyInitiatorPokNProof(msg, paillier.publicKey(), ctx));
    }
}