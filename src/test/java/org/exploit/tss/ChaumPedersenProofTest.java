package org.exploit.tss;

import org.exploit.gmp.BigInt;
import org.exploit.secp256k1.Secp256k1CurveParams;
import org.exploit.secp256k1.Secp256k1PointOps;
import org.exploit.tss.proof.model.ChaumPedersenProof;
import org.exploit.tss.proof.model.context.ChaumPedersenContext;
import org.exploit.tss.proof.pedersen.ChaumPedersenProofGenerator;
import org.exploit.tss.proof.pedersen.ChaumPedersenProofValidator;
import org.exploit.tss.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class ChaumPedersenProofTest {
    private Secp256k1CurveParams CURVE;
    private BigInt Q;
    private Secp256k1PointOps G;
    private Secp256k1PointOps H;

    private ChaumPedersenProofGenerator<Secp256k1PointOps> generator;
    private ChaumPedersenProofValidator<Secp256k1PointOps> validator;

    @BeforeEach
    void init() {
        TSS.loadLibraries();

        CURVE = new Secp256k1CurveParams();
        Q = CURVE.getCurveOrder();
        G = CURVE.getG();
        H = CURVE.getGeneratorH();

        generator = new ChaumPedersenProofGenerator<>(Q, G, H);
        validator = new ChaumPedersenProofValidator<>(Q, G, H);
    }

    @RepeatedTest(64)
    void proofVerifies() {
        var secret = randomScalar();
        var t = randomScalar();
        var T = G.mul(secret).add(H.mul(t)).normalize();

        var ctx = new ChaumPedersenContext<>(t, T);
        var proof = generator.createProof(secret, ctx);

        assertTrue(validator.verifyProof(proof, T, null));
    }

    @Test
    void tamperRBreaks() {
        var data = buildContext();
        var proof = generator.createProof(data.secret, data.ctx);
        var bad = new ChaumPedersenProof<>(proof.A(), proof.r().add(BigInt.ONE).mod(Q), proof.s());

        assertFalse(validator.verifyProof(bad, data.ctx.T(), null));
    }

    @Test
    void tamperSBreaks() {
        var data = buildContext();
        var proof = generator.createProof(data.secret, data.ctx);
        var bad = new ChaumPedersenProof<>(proof.A(), proof.r(), proof.s().add(BigInt.ONE).mod(Q));
        assertFalse(validator.verifyProof(bad, data.ctx.T(), null));
    }

    @Test
    void tamperABreaks() {
        var data = buildContext();
        var proof = generator.createProof(data.secret, data.ctx);
        var bad = new ChaumPedersenProof<>(proof.A().add(G), proof.r(), proof.s());

        assertFalse(validator.verifyProof(bad, data.ctx.T(), null));
    }

    @Test
    void edge_secret1_t1() {
        runEdgeCase(BigInt.ONE, BigInt.ONE);
    }

    @Test
    void edge_secret1_tMinus1() {
        runEdgeCase(BigInt.ONE, Q.subtract(BigInt.ONE));
    }

    @Test
    void edge_secretMinus1_t1() {
        runEdgeCase(Q.subtract(BigInt.ONE), BigInt.ONE);
    }

    @Test
    void edge_secretMinus1_tMinus1() {
        runEdgeCase(Q.subtract(BigInt.ONE), Q.subtract(BigInt.ONE));
    }

    private void runEdgeCase(BigInt secret, BigInt t) {
        var T = G.mul(secret).add(H.mul(t)).normalize();
        var ctx = new ChaumPedersenContext<>(t, T);
        var proof = generator.createProof(secret, ctx);

        assertTrue(validator.verifyProof(proof, T, null));
    }

    private BigInt randomScalar() {
        BigInt s;
        do {
            s = new BigInt(Q.bitLength(), ZKRandom.getRandom()).mod(Q);
        } while (s.signum() == 0);
        return s;
    }

    private ContextData buildContext() {
        var secret = randomScalar();
        var t = randomScalar();
        var T = G.mul(secret).add(H.mul(t)).normalize();
        var ctx = new ChaumPedersenContext<>(t, T);

        return new ContextData(secret, ctx);
    }

    private record ContextData(BigInt secret, ChaumPedersenContext<Secp256k1PointOps> ctx) {}
}