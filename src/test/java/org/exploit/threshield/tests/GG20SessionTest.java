package org.exploit.threshield.tests;

import org.exploit.crypto.Hash;
import org.exploit.crypto.curve.Secp256k1Provider;
import org.exploit.crypto.key.secp256k1.Secp256k1KeyPair;
import org.exploit.crypto.signature.ECDSASignature;
import org.exploit.threshield.constant.GG18;
import org.exploit.threshield.constant.GG18.ComputationType;
import org.exploit.threshield.ecdsa.ThresholdECDSAClient;
import org.exploit.threshield.ecdsa.commitment.GammaCommitment;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.threshield.ecdsa.context.crypto.CryptoContext;
import org.exploit.threshield.ecdsa.context.init.InitContext;
import org.exploit.threshield.ecdsa.context.mta.MtAContext;
import org.exploit.threshield.ecdsa.context.signature.SignatureContext;
import org.exploit.threshield.model.ECCurveParams;
import org.exploit.threshield.util.Sum;
import org.exploit.zktrust.share.ECShamirKeySplitter;
import org.exploit.zktrust.share.model.ECKeyShare;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class GG20SessionTest {
    private static final String SESSION_ID = "test";

    private byte[] message;
    private Secp256k1KeyPair keyPair;

    private final List<Integer> participants = List.of(1, 2);
    private final Map<Integer, ThresholdECDSAClient> clients = new HashMap<>();

    @BeforeEach
    public void init() {
        this.message = Hash.sha256("Hello, world!".getBytes());
        this.keyPair = Secp256k1Provider.getInstance().generateKeyPair();

        var threshold = 1;
        var total = 2;

        var splitter = new ECShamirKeySplitter(
                Secp256k1Provider.getCurveOrder(),
                Secp256k1Provider.CURVE.getG(),
                threshold, total
        );

        var shares = splitter.splitKey(keyPair.privateKey().toBigInt()).shares();
        assertEquals(splitter.recoverKey(shares), keyPair.privateKey().toBigInt());

        for (var share : shares) {
            var context = createContext(share);
            var client = new ThresholdECDSAClient(SESSION_ID, context, GG18.CommitmentGenerator.SECP256k1);
            client.init();

            clients.put(share.index(), client);
        }
    }

    @Test
    public void assertValidSignature() {
        broadcastGammaPederson();

        for (var idx : participants) {
            doMta(idx);
        }

        collectOfflinePhase();

        var r = clients.get(participants.get(0)).signature().computeSignatureR();
        var s = calculateSignatureS();

        var signature = new ECDSASignature(r, s, (byte) 0);
        assertTrue(Secp256k1Provider.getInstance().verify(message, signature, keyPair.publicKey()));
    }

    private void broadcastGammaPederson() {
        for (var i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var clientJ = clients.get(participants.get(j));
                var commitment = clientJ.context().crypto().ephemeral().commitment();
                var r_i = clientJ.context().crypto().ephemeral().r_i();

                clientI.context().integrity().storeGammaCommitment(participants.get(j), new GammaCommitment(commitment, r_i));
            }
        }
    }

    private BigInteger calculateSignatureS() {
        var sShares = new ArrayList<BigInteger>();

        for (var client : clients.values()) {
            sShares.add(client.signature().computePartialS());
        }

        return Sum.modSum(BigInteger.ZERO, Secp256k1Provider.getCurveOrder(), sShares);
    }

    private void collectOfflinePhase() {
        for (int i = 0; i < participants.size(); i++) {
            var clientI = clients.get(participants.get(i));

            for (var j = 0; j < participants.size(); j++) {
                if (j == i) continue;

                var peerId = participants.get(j);
                var clientJ = clients.get(peerId);
                var gamma = clientJ.context().crypto().ephemeral().Gamma_i();
                var deltaShare = clientJ.signature().computeDeltaShare();

                var lambdaCommitment = clientJ.integrity().computeLambdaI();
                var sigmaCommitment = clientJ.integrity().computeSigmaCommitment();

                clientI.signature().storeGamma(peerId, gamma);
                clientI.integrity().storeLambdaCommitment(peerId, lambdaCommitment);
                clientI.integrity().storeSigmaCommitment(peerId, sigmaCommitment);
                clientI.context().signature().storeDeltaShare(peerId, deltaShare);
            }
        }
    }

    private void doMta(int idx) {
        var initiator = clients.get(idx);
        var initiatorMessage = initiator.context().mta().initiator().message();

        var zkSetup = initiator.context().crypto().zkSetup();
        var publicKey = initiator.context().crypto().paillier()
                .publicKey();

        var respondents = clients.values().stream()
                .filter(c -> c.context().init().idx() != idx)
                .toList();

        for (var respondent : respondents) {
            var peerId = respondent.context().init().idx();
            var alpha = respondent.mta().asRespondent().compute(ComputationType.GAMMA, idx,
                    publicKey, zkSetup, initiatorMessage);

            var mu = respondent.mta().asRespondent().compute(ComputationType.LAGRANGE, idx,
                    publicKey, zkSetup, initiatorMessage);

            initiator.mta().asInitiator().store(ComputationType.GAMMA, peerId, alpha);
            initiator.mta().asInitiator().store(ComputationType.LAGRANGE, peerId, mu);
        }
    }

    private GG20Context createContext(ECKeyShare keyShare) {
        var curveParams = new ECCurveParams(Secp256k1Provider.getCurveOrder(), Secp256k1Provider.CURVE.getG());

        var initContext = InitContext.inMemoryBuilder()
                .additionalContext(new byte[0])
                .threshold(1)
                .totalPeers(2)
                .message(message)
                .idx(keyShare.index())
                .participants(participants)
                .build();

        var cryptoContext = CryptoContext.inMemoryBuilder()
                .curve(curveParams)
                .publicKey(keyPair.publicKey())
                .lagrangeShare(keyShare.share(), keyShare.index(), participants, Secp256k1Provider.getCurveOrder())
                .build();

        return GG20Context.newBuilder()
                .init(initContext)
                .mta(MtAContext.inMemory())
                .crypto(cryptoContext)
                .signature(SignatureContext.inMemory())
                .build();
    }
}
