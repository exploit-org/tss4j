package org.exploit.threshield;

import com.sun.jna.NativeLibrary;
import org.exploit.gmp.BigInt;
import org.exploit.threshield.pallier.Paillier;
import org.exploit.threshield.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class PaillierTest {
    @BeforeEach
    public void setUp() {
        NativeLibrary.addSearchPath("gmp", "/opt/homebrew/Cellar/gmp/6.3.0/lib");
    }

    @Test
    public void testEncryptionDecryption() {
        var keyPair = Paillier.generateKeyPair(2048);
        var paillier = new Paillier(keyPair);

        var message = new BigInt("123456789", 10);
        var ciphertext = paillier.encrypt(message);
        var decrypted = paillier.decrypt(ciphertext);
        
        assertEquals(message, decrypted, "Decrypted message should match the original message.");
    }

    @Test
    public void testHomomorphicAddition() {
        var keyPair = Paillier.generateKeyPair(2048);
        var paillier = new Paillier(keyPair);

        var m1 = new BigInt("12345");
        var m2 = new BigInt("67890");
        var c1 = paillier.encrypt(m1);
        var c2 = paillier.encrypt(m2);

        var combinedCiphertext = c1.multiply(c2).mod(keyPair.publicKey().nsquare());
        var decryptedSum = paillier.decrypt(combinedCiphertext);

        var expected = m1.add(m2).mod(keyPair.publicKey().n());
        assertEquals(expected, decryptedSum, "Homomorphic addition should yield (m1 + m2) mod n.");
    }

    @Test
    public void testHomomorphicMultiplicationByConstant() {
        var keyPair = Paillier.generateKeyPair(2048);
        var paillier = new Paillier(keyPair);

        var m = new BigInt("54321");
        var k = new BigInt("5");
        var ciphertext = paillier.encrypt(m);

        var ciphertextRaised = ciphertext.modPow(k, keyPair.publicKey().nsquare());
        var decryptedResult = paillier.decrypt(ciphertextRaised);

        var expected = m.multiply(k).mod(keyPair.publicKey().n());
        assertEquals(expected, decryptedResult, "Homomorphic multiplication by constant should yield (k * m) mod n.");
    }

    @Test
    public void testPaillierBigValues() {
        var startGenerate = System.currentTimeMillis();

        var paillier = new Paillier(Paillier.generateKeyPair(4096));
        var endGenerate = System.currentTimeMillis();
        System.out.println(endGenerate - startGenerate);

        var start = System.currentTimeMillis();
        var m = new BigInt("1234567890123456789012345678901234567890");
        var c = paillier.encrypt(m);
        var decrypted = paillier.decrypt(c);
        assertEquals(m, decrypted);

        var k1 = new BigInt("71098809159346792440188158440028282280925665351438723576150487647335846817170");
        var w2 = new BigInt("21755534543430484531076988177720051073363648616530701301471186306104592503202");
        var y = new BigInt(1280, ZKRandom.getRandom()).mod(new BigInt("2").pow(1280));
        var mLarge = k1.multiply(w2).add(y);
        c = paillier.encrypt(mLarge);
        decrypted = paillier.decrypt(c);

        var end = System.currentTimeMillis();
        System.out.println(end - start);
        assertEquals(mLarge, decrypted);
    }

    @Test
    public void testEncryptWithInvalidMessage() {
        var keyPair = Paillier.generateKeyPair(2048);
        var paillier = new Paillier(keyPair);

        var negativeMessage = BigInt.valueOf(-1);
        assertThrows(IllegalArgumentException.class, () -> paillier.encrypt(negativeMessage),
                "Should not encrypt negative message.");

        var invalidMessage = keyPair.publicKey().n();
        assertThrows(IllegalArgumentException.class, () -> paillier.encrypt(invalidMessage),
                "Should not encrypt message equal to n.");
    }
}