package org.exploit.threshield;

import com.sun.jna.NativeLibrary;
import org.exploit.gmp.BigInt;
import org.exploit.threshield.pallier.Paillier;
import org.exploit.threshield.proof.model.PaillierZKProof;
import org.exploit.threshield.proof.model.context.PaillierSigmaContext;
import org.exploit.threshield.proof.model.witness.PaillierEncryptionWitness;
import org.exploit.threshield.proof.paillier.PaillierZKProofGenerator;
import org.exploit.threshield.proof.paillier.PaillierZKProofValidator;
import org.exploit.threshield.util.ZKRandom;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class PaillierZKProofValidatorTest {
    @BeforeEach
    public void setUp() {
        NativeLibrary.addSearchPath("gmp", "/opt/homebrew/Cellar/gmp/6.3.0/lib");
    }

    @Test
    public void testValidProofVerification() {
        var keyPair = Paillier.generateKeyPair(2048);
        var pubKey = keyPair.publicKey();
        var n = pubKey.n();
        var nsquare = pubKey.nsquare();
        var g = pubKey.g();

        var m = new BigInt(n.bitLength(), ZKRandom.getRandom()).mod(n);

        BigInt r;
        do {
            r = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r.compareTo(n) >= 0 || !r.gcd(n).equals(BigInt.ONE));

        var c = g.modPow(m, nsquare)
                .multiply(r.modPow(n, nsquare))
                .mod(nsquare);

        var witness = new PaillierEncryptionWitness(m, r, c, pubKey);

        var generator = new PaillierZKProofGenerator();
        var context = "testContext".getBytes();
        var proof = generator.createProof(witness, context);

        var sigmaContext = new PaillierSigmaContext(c, context);

        var validator = new PaillierZKProofValidator();
        var isValid = validator.verifyProof(proof, pubKey, sigmaContext);

        assertTrue(isValid, "Proof should be valid for the correct witness.");
    }

    @Test
    public void testInvalidProofVerification() {
        var keyPair = Paillier.generateKeyPair(2048);
        var pubKey = keyPair.publicKey();
        var n = pubKey.n();
        var nsquare = n.multiply(n);
        var g = pubKey.g();

        var m = new BigInt(n.bitLength(), ZKRandom.getRandom()).mod(n);
        BigInt r;
        do {
            r = new BigInt(n.bitLength(), ZKRandom.getRandom());
        } while (r.compareTo(n) >= 0 || !r.gcd(n).equals(BigInt.ONE));

        var c = g.modPow(m, nsquare)
                .multiply(r.modPow(n, nsquare))
                .mod(nsquare);

        var witness = new PaillierEncryptionWitness(m, r, c, pubKey);

        var generator = new PaillierZKProofGenerator();
        var context = "testContext".getBytes();
        var proof = generator.createProof(witness, context);

        var invalidProof = new PaillierZKProof(
                proof.commitment(),
                proof.s_m().add(BigInt.ONE),
                proof.s_r()
        );

        var sigmaContext = new PaillierSigmaContext(c, context);

        var validator = new PaillierZKProofValidator();
        var isValid = validator.verifyProof(invalidProof, pubKey, sigmaContext);

        assertFalse(isValid, "Proof should be invalid if the response is tampered with.");
    }
}