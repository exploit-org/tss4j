package org.exploit.tss.mta;


import org.exploit.gmp.BigInt;
import org.exploit.tss.mta.model.MtAInitiatorMessage;
import org.exploit.tss.mta.model.MtAResult;
import org.exploit.tss.pallier.Paillier;
import org.exploit.tss.pallier.key.PaillierKeyPair;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.model.ZKSetup;
import org.exploit.tss.proof.model.context.PaillierRangeProofContext;
import org.exploit.tss.proof.model.context.PaillierRespondentProofContext;
import org.exploit.tss.proof.model.witness.PaillierRangeEncryptionWitness;
import org.exploit.tss.proof.model.witness.PaillierRespondentEncryptionWitness;
import org.exploit.tss.proof.paillier.PaillierRangeProofGenerator;
import org.exploit.tss.proof.paillier.PaillierRangeProofValidator;
import org.exploit.tss.proof.paillier.PaillierRespondentProofGenerator;
import org.exploit.tss.proof.paillier.PaillierRespondentProofValidator;
import org.exploit.tss.util.ZKRandom;

import java.util.Objects;

public class MtAProtocol {
    private final Paillier paillier;
    private final BigInt q;

    public MtAProtocol(Paillier paillier, BigInt q) {
        validatePaillierN(Objects.requireNonNull(paillier), Objects.requireNonNull(q));
        this.paillier = paillier;
        this.q = q;
    }

    public MtAInitiatorMessage generateInitiatorMessage(BigInt a_i, ZKSetup zkSetup, byte[] context) {
        if (a_i == null || a_i.signum() < 0 || a_i.compareTo(q) >= 0) {
            throw new IllegalArgumentException("a_i must be in [0, q)");
        }
        var encryption = paillier.encryptWithRandomness(a_i);
        var cA = encryption.c();
        var r = encryption.r();

        var proofGen = new PaillierRangeProofGenerator();
        var witness = new PaillierRangeEncryptionWitness(a_i, r, cA, paillier.publicKey(), zkSetup, q);
        var proof = proofGen.createProof(witness, context);

        return new MtAInitiatorMessage(cA, proof);
    }

    public boolean verifyInitiatorProof(MtAInitiatorMessage msg, PaillierPublicKey publicKey, ZKSetup zkSetup, byte[] context) {
        var validator = new PaillierRangeProofValidator();
        var ctx = new PaillierRangeProofContext(msg.cA(), q, zkSetup, context);
        return validator.verifyProof(msg.proof(), publicKey, ctx);
    }

    public MtAResult computeCjWithY(PaillierPublicKey initiatorPublicKey, BigInt c_i, BigInt b_j, ZKSetup zkSetup, byte[] context) {
        if (c_i == null || b_j == null || b_j.compareTo(q) >= 0) {
            throw new IllegalArgumentException("Inputs cannot be null and b_j must be in [0, q)");
        }

        var nsq = initiatorPublicKey.nsquare();
        var y = new BigInt(q.bitLength(), ZKRandom.getRandom()).mod(q);

        var initiatorPaillier = new Paillier(new PaillierKeyPair(initiatorPublicKey, null));
        var encY = initiatorPaillier.encryptWithRandomness(y);

        var c_j = c_i.modPow(b_j, nsq)
                .multiply(encY.c())
                .mod(nsq);

        if (zkSetup != null) {
            var proofGen = new PaillierRespondentProofGenerator();
            var witness = new PaillierRespondentEncryptionWitness(
                    b_j, y, c_i, c_j, encY.r(), initiatorPublicKey, zkSetup, q
            );
            
            var proof = proofGen.createProof(witness, context);
            return new MtAResult(c_j, y, encY.r(), proof);
        }

        return new MtAResult(c_j, y, encY.r());
    }

    public MtAResult computeCjWithY(PaillierPublicKey publicKey, BigInt c_i, BigInt b_j) {
        return computeCjWithY(publicKey, c_i, b_j, null, null);
    }

    public boolean verifyRespondentProof(MtAResult result, BigInt c_i, PaillierPublicKey publicKey, ZKSetup zkSetup, byte[] context) {
        var validator = new PaillierRespondentProofValidator();
        var ctx = new PaillierRespondentProofContext(c_i, result.c_j(), q, zkSetup, context);
        
        return validator.verifyProof(result.proof(), publicKey, ctx);
    }

    public BigInt encryptA(BigInt a_i) {
        if (a_i == null || a_i.signum() < 0 || a_i.compareTo(q) >= 0) {
            throw new IllegalArgumentException("a_i must be in [0, q)");
        }
        return paillier.encrypt(a_i);
    }

    public BigInt decryptCj(BigInt c_j) {
        if (c_j == null) {
            throw new IllegalArgumentException("c_j cannot be null");
        }
        return paillier.decrypt(c_j);
    }

    public BigInt computeBeta(BigInt y) {
        if (y == null) {
            throw new IllegalArgumentException("y cannot be null");
        }
        return y.negate().mod(q);
    }

    public Paillier paillier() {
        return paillier;
    }

    public PaillierPublicKey getPublicKey() {
        return paillier.publicKey();
    }

    public PaillierPrivateKey getPrivateKey() {
        return paillier.privateKey();
    }

    private static void validatePaillierN(Paillier paillier, BigInt q) {
        var N = paillier.publicKey().n();
        
        if (N.compareTo(q.pow(8)) < 0) {
            throw new IllegalArgumentException("Paillier public key n must be at least 8 times larger than q");
        }
    }
}