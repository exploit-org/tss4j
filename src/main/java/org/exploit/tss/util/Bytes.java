package org.exploit.tss.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Objects;

public final class Bytes {
    private Bytes() {}

    public static byte[] concat(List<byte[]> parts) {
        int len = 0;
        for (var p : parts) len += (p == null ? 0 : p.length);

        var out = new byte[len];
        int off = 0;
        for (var p : parts) {
            if (p == null || p.length == 0) continue;
            System.arraycopy(p, 0, out, off, p.length);
            off += p.length;
        }
        return out;
    }

    public static byte[] concat(byte[]... parts) {
        Objects.requireNonNull(parts, "parts");
        try (var out = new ByteArrayOutputStream()) {
            for (var p : parts) {
                out.write(p);
            }
            return out.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static byte[] encode(byte[]... parts) {
        Objects.requireNonNull(parts, "parts");
        try (var out = new ByteArrayOutputStream()) {
            for (var p : parts) {
                out.write(ByteBuffer.allocate(4).putInt(p.length).array());
                out.write(p);
            }
            return out.toByteArray();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}