package org.exploit.tss.shamir;

import lombok.Builder;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.PointOps;
import org.exploit.tss.shamir.model.ECKeyShare;
import org.exploit.tss.shamir.model.ECKeySplitResult;
import org.exploit.tss.util.ZKRandom;

import java.util.ArrayList;
import java.util.List;

@Builder(builderMethodName = "newBuilder")
public class ECShamirKeySplitter<P extends PointOps<P>> {
    private final BigInt curveOrder;
    private final PointOps<P> generator;
    private final int threshold;
    private final int totalPeers;

    public ECShamirKeySplitter(BigInt curveOrder, PointOps<P> generator, int threshold, int totalPeers) {
        if (threshold < 1 || threshold > totalPeers) {
            throw new IllegalArgumentException("threshold (k) must be between 1 and totalPeers");
        }

        this.curveOrder = curveOrder;
        this.generator = generator;
        this.threshold = threshold;
        this.totalPeers = totalPeers;
    }

    public ECKeySplitResult<P> splitKey(BigInt sk) {
        var coefficients = new BigInt[threshold];
        coefficients[0] = sk;
        for (var i = 1; i < threshold; i++) {
            coefficients[i] = new BigInt(curveOrder.bitLength(), ZKRandom.getRandom())
                    .mod(curveOrder);
        }

        List<ECKeyShare<P>> shares = new ArrayList<>(totalPeers);
        for (var i = 0; i < totalPeers; i++) {
            var x = BigInt.valueOf(i + 1);
            var sk_i = evaluatePolynomial(coefficients, x);
            var pk_i = generator.mul(sk_i).normalize();
            shares.add(new ECKeyShare<>(i + 1, sk_i, pk_i));
        }

        var pk = generator.mul(sk).normalize();
        return new ECKeySplitResult<>(shares, pk);
    }

    public BigInt recoverKey(List<ECKeyShare<P>> shares) {
        if (shares.size() < threshold) {
            throw new IllegalArgumentException("At least threshold shares are required");
        }
        var sk = BigInt.ZERO;

        var subset = shares.subList(0, threshold);
        for (var i = 0; i < threshold; i++) {
            var y_i = subset.get(i).share();
            var l_i = lagrangeCoefficient(subset, i);
            sk = sk.add(y_i.multiply(l_i)).mod(curveOrder);
        }
        return sk;
    }

    private BigInt evaluatePolynomial(BigInt[] coeffs, BigInt x) {
        var result = BigInt.ZERO;
        var xPow = BigInt.ONE;
        for (var coeff : coeffs) {
            result = result.add(coeff.multiply(xPow)).mod(curveOrder);
            xPow = xPow.multiply(x).mod(curveOrder);
        }
        return result;
    }

    private BigInt lagrangeCoefficient(List<ECKeyShare<P>> shares, int j) {
        var x_j = BigInt.valueOf(shares.get(j).index());
        var numerator = BigInt.ONE;
        var denominator = BigInt.ONE;
        for (var m = 0; m < threshold; m++) {
            if (m != j) {
                var x_m = BigInt.valueOf(shares.get(m).index());
                numerator = numerator.multiply(x_m.negate()).mod(curveOrder);
                denominator = denominator.multiply(x_j.subtract(x_m)).mod(curveOrder);
            }
        }
        var invDenom = denominator.modInverse(curveOrder);
        return numerator.multiply(invDenom).mod(curveOrder);
    }
}