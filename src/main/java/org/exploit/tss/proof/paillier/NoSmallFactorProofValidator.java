package org.exploit.tss.proof.paillier;

import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.NoSmallFactorProof;
import org.exploit.tss.proof.model.ZKSetup;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.util.Objects;

public final class NoSmallFactorProofValidator implements ZKProofValidator<NoSmallFactorProof, PaillierPublicKey, byte[]> {
    private final ZKSetup zk;
    private final int ellBits;
    private final int epsBits;

    public NoSmallFactorProofValidator(ZKSetup zk) { this(zk, 256, 16); }
    public NoSmallFactorProofValidator(ZKSetup zk, int ellBits, int epsBits) {
        this.zk = Objects.requireNonNull(zk, "zk");
        this.ellBits = ellBits;
        this.epsBits = epsBits;
    }

    @Override
    public boolean verifyProof(NoSmallFactorProof pr, PaillierPublicKey pk, byte[] context) {
        if (pr == null || pk == null) return false;

        var Ni = pk.n();
        if (Ni.bitLength() < 2048) return false;

        var Nj = zk.hatN();
        var s = zk.h1();
        var t = zk.h2();

        if (!Nj.gcd(s).equals(BigInt.ONE)) return false;
        if (!Nj.gcd(t).equals(BigInt.ONE)) return false;

        var P = new BigInt(pr.P());
        var Q = new BigInt(pr.Q());
        var A = new BigInt(pr.A());
        var B = new BigInt(pr.B());
        var T = new BigInt(pr.T());

        var z1 = pr.z1();
        var z2 = pr.z2();
        var w1 = pr.w1();
        var w2 = pr.w2();
        var v = pr.v();

        if (!inRange(z1, Ni, ellBits, epsBits)) return false;
        if (!inRange(z2, Ni, ellBits, epsBits)) return false;

        if (!Nj.gcd(P).equals(BigInt.ONE)) return false;
        if (!Nj.gcd(Q).equals(BigInt.ONE)) return false;

        var twoEll = BigInt.ONE.shiftLeft(ellBits);

        var ctx = (context == null) ? new byte[0] : context;
        var hashInput = Bytes.encode(
                Ni.toByteArray(),
                Nj.toByteArray(),
                s.toByteArray(),
                t.toByteArray(),
                P.toByteArray(),
                Q.toByteArray(),
                A.toByteArray(),
                B.toByteArray(),
                T.toByteArray(),
                ctx
        );

        var eRaw = new BigInt(1, Hash.sha256(hashInput)).mod(twoEll);
        var e = toSigned(eRaw, twoEll);

        var lhs1 = multiexpSigned(Nj, s, z1, t, w1);
        var rhs1 = A.multiply(powSigned(P, e, Nj)).mod(Nj);

        if (!lhs1.equals(rhs1)) return false;

        var lhs2 = multiexpSigned(Nj, s, z2, t, w2);
        var rhs2 = B.multiply(powSigned(Q, e, Nj)).mod(Nj);

        if (!lhs2.equals(rhs2)) return false;

        var lhs3 = powSigned(Q, z1, Nj).multiply(powSigned(t, v, Nj)).mod(Nj);
        var rhs3 = T.multiply(powSigned(s, Ni.multiply(e), Nj)).mod(Nj);

        return lhs3.equals(rhs3);
    }

    private static boolean inRange(BigInt z, BigInt Ni, int ellBits, int epsBits) {
        var sqrtNiUp = BigInt.ONE.shiftLeft((Ni.bitLength() + 1) >>> 1);
        var bound = BigInt.ONE.shiftLeft(ellBits + epsBits).multiply(sqrtNiUp);
        var az = z.signum() >= 0 ? z : z.negate();
        return az.compareTo(bound) <= 0;
    }

    private static BigInt multiexpSigned(BigInt mod, BigInt a, BigInt e1, BigInt b, BigInt e2) {
        return powSigned(a, e1, mod).multiply(powSigned(b, e2, mod)).mod(mod);
    }

    private static BigInt powSigned(BigInt base, BigInt exp, BigInt mod) {
        if (exp.signum() >= 0) return base.modPow(exp, mod);
        var inv = base.modInverse(mod);
        return inv.modPow(exp.negate(), mod);
    }

    private static BigInt toSigned(BigInt x, BigInt twoEll) {
        var half = twoEll.shiftRight(1);
        return x.compareTo(half) >= 0 ? x.subtract(twoEll) : x;
    }
}