package org.exploit.tss.proof.paillier;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.PaillierRespondentProof;
import org.exploit.tss.proof.model.witness.PaillierRespondentEncryptionWitness;
import org.exploit.tss.util.ZKRandom;

public class PaillierRespondentProofGenerator implements ZKProofGenerator<PaillierRespondentProof, PaillierRespondentEncryptionWitness, byte[]> {

    @Override
    public PaillierRespondentProof createProof(PaillierRespondentEncryptionWitness witness, byte[] context) {
        var pubKey = witness.publicKey();
        var zkSetup = witness.zk();
        var g = pubKey.g();
        var n = pubKey.n();
        var nsq = pubKey.nsquare();
        var hatN = zkSetup.hatN();
        var h1 = zkSetup.h1();
        var h2 = zkSetup.h2();
        var q = witness.q();
        var q2 = q.pow(2);
        var q6 = q.pow(6);
        var hatNq = q.multiply(hatN);

        var rnd = ZKRandom.getRandom();

        var alpha = new BigInt(q2.bitLength(), rnd).mod(q2);
        var beta = new BigInt(n.bitLength(), rnd).mod(n);
        var gamma = new BigInt(q6.bitLength(), rnd).mod(q6);
        var rho = new BigInt(hatNq.bitLength(), rnd).mod(hatNq);
        var sigma = new BigInt(hatNq.bitLength(), rnd).mod(hatN);
        var tau = new BigInt(q6.bitLength(), rnd).mod(q6);

        var z = h1.modPow(witness.b(), hatN).multiply(h2.modPow(rho, hatN)).mod(hatN);
        var zPrime = h1.modPow(alpha, hatN).multiply(h2.modPow(sigma, hatN)).mod(hatN);

        var t = h1.modPow(witness.y(), hatN).multiply(h2.modPow(tau, hatN)).mod(hatN);

        var v = witness.c_i().modPow(alpha, nsq)
                .multiply(g.modPow(gamma, nsq))
                .multiply(beta.modPow(n, nsq))
                .mod(nsq);

        var w = h1.modPow(gamma, hatN).multiply(h2.modPow(tau, hatN)).mod(hatN);

        var hashInput = Bytes.from(
                witness.c_i().toByteArray(),
                witness.c_j().toByteArray(),
                z.toByteArray(),
                zPrime.toByteArray(),
                t.toByteArray(),
                v.toByteArray(),
                w.toByteArray(),
                context
        ).array();

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(q);

        var s1 = e.multiply(witness.b()).add(alpha);
        var s2 = e.multiply(rho).add(sigma);
        var t1 = e.multiply(witness.y()).add(gamma);
        var t2 = e.multiply(tau).add(tau);

        var s = witness.r().modPow(e, n).multiply(beta).mod(n);

        return new PaillierRespondentProof(
                z.toByteArray(),
                zPrime.toByteArray(),
                t.toByteArray(),
                v.toByteArray(),
                w.toByteArray(),
                s.toByteArray(),
                s1, s2,
                t1, t2
        );
    }
}