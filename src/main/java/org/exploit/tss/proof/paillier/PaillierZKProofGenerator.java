package org.exploit.tss.proof.paillier;

import org.exploit.tss.util.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.PaillierZKProof;
import org.exploit.tss.proof.model.witness.PaillierEncryptionWitness;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.ZKRandom;

import static org.exploit.tss.util.BigIntUtils.randomZnStar;

public class PaillierZKProofGenerator implements ZKProofGenerator<PaillierZKProof, PaillierEncryptionWitness, byte[]> {
    @Override
    public PaillierZKProof createProof(PaillierEncryptionWitness witness, byte[] context) {
        var pubKey = witness.publicKey();

        var alpha = new BigInt(pubKey.n().bitLength(), ZKRandom.getRandom()).mod(pubKey.n());

        var beta = randomZnStar(pubKey.n(), ZKRandom.getRandom());

        var T = pubKey.g().modPow(alpha, pubKey.nsquare())
                .multiplySec(beta.modPow(pubKey.n(), pubKey.nsquare()))
                .mod(pubKey.nsquare());

        var hashInput = Bytes.encode(
                pubKey.g().toByteArray(),
                witness.c().toByteArray(),
                T.toByteArray(),
                context
        );

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(pubKey.n());

        var s_m = alpha.add(e.multiplySec(witness.m()));
        var s_r = beta.multiplySec(witness.r().modPow(e, pubKey.n())).mod(pubKey.n());

        return new PaillierZKProof(T.toByteArray(), s_m, s_r);
    }
}