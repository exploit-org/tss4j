package org.exploit.tss.proof.paillier;

import org.exploit.gmp.BigInt;
import org.exploit.tss.TSS;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.PaillierRangeProof;
import org.exploit.tss.proof.model.witness.PaillierRangeEncryptionWitness;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;

import java.util.Objects;

import static org.exploit.tss.util.BigIntUtils.randomZnStar;

public class PaillierRangeProofGenerator implements ZKProofGenerator<PaillierRangeProof, PaillierRangeEncryptionWitness, byte[]> {
    @Override
    public PaillierRangeProof createProof(PaillierRangeEncryptionWitness witness, byte[] context) {
        Objects.requireNonNull(witness, "witness");

        var pubKey = witness.publicKey();
        var zkSetup = witness.zk();

        var n = pubKey.n();
        var nsq = pubKey.nsquare();

        var hatN = zkSetup.hatN();
        var h1 = zkSetup.h1();
        var h2 = zkSetup.h2();

        var q = witness.q();
        var q2 = q.pow(2);

        var rnd = ZKRandom.getRandom();

        var alpha = randomZnStar(q2, rnd);
        var beta = randomZnStar(n, rnd);
        var gamma = randomZnStar(q2.multiply(hatN), rnd);
        var rho = randomZnStar(q.multiply(hatN), rnd);

        var gPowAlpha = onePlusN(alpha, n, nsq);

        var betaPowN = TSS.getPool().submit(() -> beta.modPow(n, nsq));
        var h1m = TSS.getPool().submit(() -> h1.modPowSec(witness.m(), hatN));
        var h2rho = TSS.getPool().submit(() -> h2.modPowSec(rho, hatN));
        var h1alpha = TSS.getPool().submit(() -> h1.modPowSec(alpha, hatN));
        var h2gamma = TSS.getPool().submit(() -> h2.modPowSec(gamma, hatN));

        BigInt z, u, w;

        try {
            z = h1m.get().multiply(h2rho.get()).mod(hatN);
            u = gPowAlpha.multiply(betaPowN.get()).mod(nsq);
            w = h1alpha.get().multiply(h2gamma.get()).mod(hatN);
        } catch (Exception e) {
            throw new IllegalStateException("range proof parallel step failed", e);
        }

        var ctx = (context == null) ? new byte[0] : context;

        var hashInput = Bytes.encode(
                witness.c().toByteArray(),
                z.toByteArray(),
                u.toByteArray(),
                w.toByteArray(),
                ctx
        );

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(q);

        var s = witness.r().modPowSec(e, n).multiply(beta).mod(n);
        var s1 = e.multiplySec(witness.m()).add(alpha);
        var s2 = e.multiplySec(rho).add(gamma);

        return new PaillierRangeProof(z.toByteArray(), u.toByteArray(), w.toByteArray(), s.toByteArray(), s1, s2);
    }

    private static BigInt onePlusN(BigInt k, BigInt n, BigInt nsq) {
        return BigInt.ONE.add(n.multiply(k)).mod(nsq);
    }
}