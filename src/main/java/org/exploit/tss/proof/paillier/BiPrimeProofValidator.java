package org.exploit.tss.proof.paillier;

import org.exploit.gmp.BigInt;
import org.exploit.tss.TSS;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.BiPrimeBlumProof;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.stream.IntStream;

public final class BiPrimeProofValidator implements ZKProofValidator<BiPrimeBlumProof, PaillierPublicKey, byte[]> {
    @Override
    public boolean verifyProof(BiPrimeBlumProof pr, PaillierPublicKey pk, byte[] ctx) {
        if (!basicChecks(pr, pk))
            return false;

        BigInt N = pr.N(), w = pr.w();
        var A = unpack(pr.aBits(), pr.blumRounds());
        var B = unpack(pr.bBits(), pr.blumRounds());

        return verifySigmaRounds(pr, N) && verifyBlumRounds(pr, N, w, ctx, A, B);
    }

    private static boolean basicChecks(BiPrimeBlumProof pr, PaillierPublicKey pk) {
        if (pr == null || pk == null)
            return false;

        if (!pk.n().equals(pr.N()))
            return false;

        if (pr.sigmas() == null || pr.xs() == null || pr.zs() == null)
            return false;

        int sf = pr.sfRounds(), blum = pr.blumRounds();

        if (pr.sigmas().size() != sf || pr.xs().size() != blum || pr.zs().size() != blum)
            return false;

        return BigInt.jacobi(pr.w(), pr.N()) == -1;
    }

    private static boolean verifySigmaRounds(BiPrimeBlumProof pr, BigInt N) {
        var sf = pr.sfRounds();
        var tasks = IntStream.range(0, sf)
                .<Callable<Boolean>>mapToObj(i -> () -> verifySigma(pr.sigmas().get(i), N))
                .toList();

        return allMatch(tasks);
    }

    private static boolean verifyBlumRounds(BiPrimeBlumProof pr, BigInt N, BigInt w, byte[] ctx, boolean[] A, boolean[] B) {
        var blum = pr.blumRounds();

        var tasks = IntStream.range(0, blum)
                .<Callable<Boolean>>mapToObj(i -> () -> verifyBlumRound(pr, N, w, ctx, A[i], B[i], i))
                .toList();

        return allMatch(tasks);
    }

    private static boolean verifySigma(BigInt sigma, BigInt N) {
        if (sigma.signum() <= 0 || sigma.compareTo(N) >= 0)
            return false;
        if (sigma.equals(BigInt.ONE) || sigma.equals(N.subtract(BigInt.ONE)))
            return false;

        if (!sigma.gcd(N).equals(BigInt.ONE))
            return false;

        return sigma.subtract(BigInt.ONE).gcd(N).equals(BigInt.ONE);
    }

    private static boolean allMatch(List<Callable<Boolean>> tasks) {
        try {
            for (var f : TSS.getPool().invokeAll(tasks))
                if (!f.get())
                    return false;
            return true;
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    private static boolean verifyBlumRound(BiPrimeBlumProof pr, BigInt N, BigInt w, byte[] ctx, boolean a, boolean b, int i) {
        var x = pr.xs().get(i);
        var z = pr.zs().get(i);

        if (x.signum() < 0 || x.compareTo(N) >= 0)
            return false;

        if (z.signum() < 0 || z.compareTo(N) >= 0)
            return false;

        var y = BiPrimeProofGenerator.genY(N, w, ctx, i);
        if (!z.modPow(N, N).equals(y)) return false;

        var rhs = y;

        if (b) rhs = rhs.multiply(w).mod(N);
        if (a) rhs = N.subtract(rhs).mod(N);

        var x2 = x.multiply(x).mod(N);
        var x4 = x2.multiply(x2).mod(N);

        return x4.equals(rhs);
    }

    private static boolean[] unpack(byte[] arr, int len) {
        var out = new boolean[len];

        for (var i = 0; i < len; ++i)
            out[i] = (arr[i >>> 3] & (1 << (i & 7))) != 0;

        return out;
    }
}