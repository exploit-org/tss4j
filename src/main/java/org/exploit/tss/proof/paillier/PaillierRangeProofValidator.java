package org.exploit.tss.proof.paillier;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.PaillierRangeProof;
import org.exploit.tss.proof.model.context.PaillierRangeProofContext;

public class PaillierRangeProofValidator implements ZKProofValidator<PaillierRangeProof, PaillierPublicKey, PaillierRangeProofContext> {
    @Override
    public boolean verifyProof(PaillierRangeProof proof, PaillierPublicKey pubKey, PaillierRangeProofContext ctx) {
        var g = pubKey.g();
        var n = pubKey.n();
        var nsq = pubKey.nsquare();
        var hatN = ctx.zkSetup().hatN();
        var h1 = ctx.zkSetup().h1();
        var h2 = ctx.zkSetup().h2();

        var z = new BigInt(proof.z());
        var u = new BigInt(proof.u());
        var w = new BigInt(proof.w());
        var s = new BigInt(proof.s());
        var s1 = proof.s1();
        var s2 = proof.s2();

        var hashInput = Bytes.from(
            ctx.c().toByteArray(),
            z.toByteArray(),
            u.toByteArray(),
            w.toByteArray(),
            ctx.additionalData()
        ).array();

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(ctx.q());

        var q3 = ctx.q().pow(3);
        if (s1.compareTo(q3) > 0) {
            return false;
        }

        var left1 = g.modPow(s1, nsq)
                .multiply(s.modPow(n, nsq))
                .mod(nsq);

        var right1 = u.multiply(ctx.c().modPow(e, nsq)).mod(nsq);

        if (!left1.equals(right1)) {
            return false;
        }

        var left2 = h1.modPow(s1, hatN)
                .multiply(h2.modPow(s2, hatN))
                .mod(hatN);

        var right2 = z.modPow(e, hatN).multiply(w).mod(hatN);

        return left2.equals(right2);
    }
}