package org.exploit.tss.proof.paillier;

import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.NoSmallFactorProof;
import org.exploit.tss.proof.model.ZKSetup;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;

import java.util.Objects;
import java.util.Random;

public final class NoSmallFactorProofGenerator implements ZKProofGenerator<NoSmallFactorProof, PaillierPrivateKey, byte[]> {
    private final ZKSetup zk;
    private final int ellBits;
    private final int epsBits;

    public NoSmallFactorProofGenerator(ZKSetup zk) { this(zk, 256, 16); }

    public NoSmallFactorProofGenerator(ZKSetup zk, int ellBits, int epsBits) {
        this.zk = Objects.requireNonNull(zk, "zk");
        this.ellBits = ellBits;
        this.epsBits = epsBits;
    }

    @Override
    public NoSmallFactorProof createProof(PaillierPrivateKey priv, byte[] context) {
        Objects.requireNonNull(priv, "priv");
        var Ni = priv.publicKey().n();
        var Nj = zk.hatN();
        var s = zk.h1();
        var t = zk.h2();

        var rnd = ZKRandom.getRandom();

        var sqrtNiUp = sqrtUpper(Ni);
        var twoEll = BigInt.ONE.shiftLeft(ellBits);
        var twoEllEps = BigInt.ONE.shiftLeft(ellBits + epsBits);

        var alpha = randomSigned(twoEllEps.multiply(sqrtNiUp), rnd);
        var beta = randomSigned(twoEllEps.multiply(sqrtNiUp), rnd);
        var mu = randomSigned(twoEll.multiply(Nj), rnd);
        var nu = randomSigned(twoEll.multiply(Nj), rnd);
        var r = randomSigned(twoEllEps.multiply(Nj), rnd);
        var x = randomSigned(twoEllEps.multiply(Nj), rnd);
        var y = randomSigned(twoEllEps.multiply(Nj), rnd);

        var p = priv.p();
        var q = priv.q();

        var P = multiexpSigned(Nj, s, p, t, mu);
        var Q = multiexpSigned(Nj, s, q, t, nu);
        var A = multiexpSigned(Nj, s, alpha, t, x);
        var B = multiexpSigned(Nj, s, beta,  t, y);
        var T = multiexpSigned(Nj, Q, alpha, t, r);

        var ctx = (context == null) ? new byte[0] : context;
        var hashInput = Bytes.encode(
                Ni.toByteArray(),
                Nj.toByteArray(),
                s.toByteArray(),
                t.toByteArray(),
                P.toByteArray(),
                Q.toByteArray(),
                A.toByteArray(),
                B.toByteArray(),
                T.toByteArray(),
                ctx
        );

        var eRaw = new BigInt(1, Hash.sha256(hashInput)).mod(twoEll);
        var e = toSigned(eRaw, twoEll);

        var z1 = alpha.add(e.multiply(p));
        var z2 = beta.add(e.multiply(q));
        var w1 = x.add(e.multiply(mu));
        var w2 = y.add(e.multiply(nu));
        var v = r.subtract(nu.multiply(e).multiply(p));

        return new NoSmallFactorProof(
                P.toByteArray(), Q.toByteArray(), A.toByteArray(), B.toByteArray(), T.toByteArray(),
                z1, z2, w1, w2, v
        );
    }

    private static BigInt sqrtUpper(BigInt n) {
        var bl = n.bitLength();
        return BigInt.ONE.shiftLeft((bl + 1) >>> 1);
    }

    private static BigInt randomSigned(BigInt bound, Random rnd) {
        BigInt x;
        do { x = new BigInt(bound.bitLength() + 1, rnd); } while (x.compareTo(bound) > 0);
        return rnd.nextBoolean() ? x : x.negate();
    }

    private static BigInt multiexpSigned(BigInt mod, BigInt a, BigInt e1, BigInt b, BigInt e2) {
        return powSigned(a, e1, mod).multiplySec(powSigned(b, e2, mod)).mod(mod);
    }

    private static BigInt powSigned(BigInt base, BigInt exp, BigInt mod) {
        if (exp.signum() >= 0)
            return base.modPowSec(exp, mod);

        var inv = base.modInverseSec(mod);
        return inv.modPowSec(exp.negate(), mod);
    }

    private static BigInt toSigned(BigInt x, BigInt twoEll) {
        var half = twoEll.shiftRight(1);
        return x.compareTo(half) >= 0 ? x.subtract(twoEll) : x;
    }
}