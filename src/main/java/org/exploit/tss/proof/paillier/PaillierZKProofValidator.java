package org.exploit.tss.proof.paillier;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.PaillierZKProof;
import org.exploit.tss.proof.model.context.PaillierSigmaContext;

public class PaillierZKProofValidator implements ZKProofValidator<PaillierZKProof, PaillierPublicKey, PaillierSigmaContext> {
    @Override
    public boolean verifyProof(PaillierZKProof proof, PaillierPublicKey pubKey, PaillierSigmaContext context) {
        var hashInput = Bytes.from(
                pubKey.g().toByteArray(),
                context.ciphertext().toByteArray(),
                proof.commitment(),
                context.additionalData()
        ).array();

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(pubKey.n());

        var left = pubKey.g().modPow(proof.s_m(), pubKey.nsquare())
                .multiply(proof.s_r().modPow(pubKey.n(), pubKey.nsquare()))
                .mod(pubKey.nsquare());

        var T = new BigInt(proof.commitment());
        var right = T.multiply(context.ciphertext().modPow(e, pubKey.nsquare())).mod(pubKey.nsquare());

        return left.equals(right);
    }
}
