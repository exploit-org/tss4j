package org.exploit.tss.proof.paillier;

import org.exploit.tss.util.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.PaillierZKProof;
import org.exploit.tss.proof.model.context.PaillierSigmaContext;
import org.exploit.tss.util.Bytes;

public class PaillierZKProofValidator implements ZKProofValidator<PaillierZKProof, PaillierPublicKey, PaillierSigmaContext> {
    @Override
    public boolean verifyProof(PaillierZKProof proof, PaillierPublicKey pubKey, PaillierSigmaContext context) {
        var hashInput = Bytes.encode(
            pubKey.g().toByteArray(),
            context.ciphertext().toByteArray(),
            proof.commitment(),
            context.additionalData()
        );

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(pubKey.n());

        var left = pubKey.g().modPow(proof.s_m(), pubKey.nsquare())
                .multiply(proof.s_r().modPow(pubKey.n(), pubKey.nsquare()))
                .mod(pubKey.nsquare());

        var T = new BigInt(proof.commitment());
        var right = T.multiply(context.ciphertext().modPow(e, pubKey.nsquare())).mod(pubKey.nsquare());

        return left.equals(right);
    }
}
