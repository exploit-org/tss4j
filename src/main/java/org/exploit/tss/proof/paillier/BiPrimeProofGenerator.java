package org.exploit.tss.proof.paillier;

import org.exploit.gmp.BigInt;
import org.exploit.tss.TSS;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.BiPrimeBlumProof;
import org.exploit.tss.proof.random.DeterministicRandom;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.stream.IntStream;

import static java.util.concurrent.CompletableFuture.*;

public final class BiPrimeProofGenerator implements ZKProofGenerator<BiPrimeBlumProof, PaillierPrivateKey, byte[]> {
    private final int sfRounds;
    private final int blumRounds;

    public BiPrimeProofGenerator() {
        this(40, 64);
    }

    public BiPrimeProofGenerator(int blum) {
        this(blum, 0);
    }

    public BiPrimeProofGenerator(int blum, int sf) {
        this.sfRounds = sf;
        this.blumRounds = blum;
    }

    @Override
    public BiPrimeBlumProof createProof(PaillierPrivateKey sk, byte[] ctx) {
        BigInt p = sk.p(), q = sk.q(), N = p.multiply(q);

        validateBlum(p, q);
        var lambda = lcm(p.subtract(BigInt.ONE), q.subtract(BigInt.ONE));
        ensureCoprime(N, lambda);

        var Ninverse = positiveModInverse(N, lambda);
        var eP = Ninverse.mod(p.subtract(BigInt.ONE));
        var eQ = Ninverse.mod(q.subtract(BigInt.ONE));

        var inv4p = inv4(p);
        var inv4q = inv4(q);

        var w = pickW(N, ctx);

        var sigmas = generateSigmas(N, ctx);

        int wP = BigInt.jacobi(w, p), wQ = BigInt.jacobi(w, q);
        var blum = generateBlumRounds(N, p, q, eP, eQ, inv4p, inv4q, w, wP, wQ, ctx);

        BitSet aBits = new BitSet(blumRounds), bBits = new BitSet(blumRounds);

        List<BigInt> xs = new ArrayList<>(blumRounds);
        List<BigInt> zs = new ArrayList<>(blumRounds);

        for (var i = 0; i < blumRounds; ++i) {
            var r = blum.get(i);
            if (r.a) aBits.set(i);
            if (r.b) bBits.set(i);
            xs.add(r.x);  zs.add(r.z);
        }

        return new BiPrimeBlumProof(
                N, w, sigmas, xs,
                toByteArray(aBits, blumRounds),
                toByteArray(bBits, blumRounds),
                zs,
                sfRounds, blumRounds
        );
    }

    private static void validateBlum(BigInt p, BigInt q) {
        if (!p.and(BigInt.valueOf(3)).equals(BigInt.valueOf(3)) || !q.and(BigInt.valueOf(3)).equals(BigInt.valueOf(3)))
            throw new IllegalArgumentException("N not Blum");
    }

    private static void ensureCoprime(BigInt N, BigInt lambda) {
        if (!N.gcd(lambda).equals(BigInt.ONE))
            throw new IllegalStateException("gcd(N, lambda) != 1");
    }

    private static BigInt positiveModInverse(BigInt a, BigInt mod) {
        var x = a.modInverseSec(mod);
        return x.signum() < 0 ? x.add(mod) : x;
    }

    private static BigInt inv4(BigInt prime) {
        var half = prime.subtract(BigInt.ONE).divide(BigInt.TWO);
        return BigInt.valueOf(4).modInverseSec(half);
    }

    private static BigInt pickW(BigInt N, byte[] ctx) {
        BigInt w = null;

        for (var t = 0; t < 5_000 && w == null; ++t) {
            var cand = hashToZNStarDet(N, ctx, "w", t);
            if (BigInt.jacobi(cand, N) == -1) w = cand;
        }

        return Objects.requireNonNull(w, "could not find w in 5000 attempts");
    }

    private List<BigInt> generateSigmas(BigInt N, byte[] ctx) {
        var futures = IntStream.range(0, sfRounds)
                .mapToObj(i -> supplyAsync(() -> {
                        BigInt s, sigma;
                        do {
                            s = hashToZNStarDet(N, ctx, "sigma", i);
                            sigma = s.modPow(N, N);
                        } while (sigma.equals(BigInt.ONE) || sigma.equals(N.subtract(BigInt.ONE))
                                || !sigma.subtract(BigInt.ONE).gcd(N).equals(BigInt.ONE));

                        return sigma;
                    }, TSS.getPool()))
                .toList();
        return futures.stream().map(CompletableFuture::join).toList();
    }

    private List<Round> generateBlumRounds(
            BigInt N, BigInt p, BigInt q,
            BigInt eP, BigInt eQ,
            BigInt inv4p, BigInt inv4q,
            BigInt w, int wP, int wQ,
            byte[] ctx
    ) {
        var futures = IntStream.range(0, blumRounds)
                .mapToObj(i -> supplyAsync(() -> {
                    var y = genY(N, w, ctx, i);
                    var zp = y.mod(p).modPowSec(eP, p);
                    var zq = y.mod(q).modPowSec(eQ, q);
                    var z  = crt(zp, p, zq, q, N);

                    int yP = BigInt.jacobi(y, p), yQ = BigInt.jacobi(y, q);
                    boolean aBit = false, bBit = false;

                    search:
                    for (var B = 0; B <= 1; ++B) {
                        int sP = (B==1? wP:1) * yP, sQ = (B==1? wQ:1) * yQ;
                        for (var A = 0; A <= 1; ++A) {
                            int sp = (A==1?-sP:sP), sq = (A==1?-sQ:sQ);

                            if (sp==1 && sq==1) {
                                aBit=(A==1); bBit=(B==1);
                                break search;
                            }
                        }
                    }

                    var rhs = y;
                    if (bBit) rhs = rhs.multiply(w).mod(N);
                    if (aBit) rhs = N.subtract(rhs).mod(N);

                    var xp = rhs.mod(p).modPowSec(inv4p, p);
                    var xq = rhs.mod(q).modPowSec(inv4q, q);
                    var x = crt(xp, p, xq, q, N);

                    return new Round(x, z, aBit, bBit);
                }, TSS.getPool()))
                .toList();

        return futures.stream().map(CompletableFuture::join).toList();
    }

    static BigInt genY(BigInt N, BigInt w, byte[] ctx, int i) {
        var rnd = new DeterministicRandom(N, w, "blum", i, ctx);

        BigInt y;
        do {
            y = new BigInt(N.bitLength(), rnd);
        } while (y.signum() <= 0 || y.compareTo(N) >= 0 || !y.gcd(N).equals(BigInt.ONE));

        return y;
    }

    static BigInt hashToZNStarDet(BigInt N, byte[] ctx, String label, int i) {
        var rnd = new DeterministicRandom(N, null, label, i, ctx);

        BigInt y;
        do {
            y = new BigInt(N.bitLength(), rnd);
        } while (y.signum() <= 0 || y.compareTo(N) >= 0 || !y.gcd(N).equals(BigInt.ONE));

        return y;
    }

    private static BigInt crt(BigInt a, BigInt p, BigInt b, BigInt q, BigInt N) {
        var t = b.subtract(a).mod(q);
        var ip = p.modInverseSec(q);
        var k = t.multiply(ip).mod(q);
        var x = a.add(k.multiply(p));

        return (x.signum() < 0 || x.compareTo(N) >= 0) ? x.mod(N) : x;
    }

    private static byte[] toByteArray(BitSet bits, int len) {
        var out = new byte[(len + 7) >>> 3];

        for (var i = 0; i < len; ++i)
            if (bits.get(i)) out[i >>> 3] |= (byte) (1 << (i & 7));

        return out;
    }


    private record Round(BigInt x, BigInt z, boolean a, boolean b) {}

    private static BigInt lcm(BigInt a, BigInt b) {
        return a.multiply(b).divide(a.gcd(b));
    }
}