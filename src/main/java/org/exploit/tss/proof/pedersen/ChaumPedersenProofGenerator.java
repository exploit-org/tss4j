package org.exploit.tss.proof.pedersen;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.ChaumPedersenProof;
import org.exploit.tss.proof.model.context.ChaumPedersenContext;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;

@AllArgsConstructor
public class ChaumPedersenProofGenerator<P extends WeierstrassPointOps<P>> implements ZKProofGenerator<ChaumPedersenProof<P>, BigInt, ChaumPedersenContext<P>> {
    private final BigInt q;
    private final WeierstrassPointOps<P> g;
    private final WeierstrassPointOps<P> h;

    @Override
    public ChaumPedersenProof<P> createProof(BigInt secret, ChaumPedersenContext<P> context) {
        var rnd = ZKRandom.getRandom();

        var a = new BigInt(q.bitLength(), rnd).mod(q);
        var b = new BigInt(q.bitLength(), rnd).mod(q);

        var A = g.mul(a).add(h.mul(b)).normalize();
        var c = computeChallenge(context.T(), A);

        var rResp = a.add(c.multiplySec(secret)).mod(q);
        var sResp = b.add(c.multiplySec(context.t())).mod(q);

        return new ChaumPedersenProof<>(A, rResp, sResp);
    }

    private BigInt computeChallenge(WeierstrassPointOps<P> T, WeierstrassPointOps<P> A) {
        var bytes = Bytes.encode(g.encode(true), h.encode(true), T.encode(true), A.encode(true));
        return new BigInt(1, Hash.sha256(bytes)).mod(q);
    }
}
