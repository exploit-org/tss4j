package org.exploit.tss.proof.dleq;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.proof.ZKProofValidator;
import org.exploit.tss.proof.model.DleqProof;
import org.exploit.tss.proof.model.context.DleqContext;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;

import java.util.List;

@AllArgsConstructor
public class DleqProofValidator<P extends WeierstrassPointOps<P>> implements ZKProofValidator<DleqProof<P>, DleqContext<P>, Void> {
    private final BigInt q;
    private final WeierstrassPointOps<P> g;

    @Override
    public boolean verifyProof(DleqProof<P> pf, DleqContext<P> ctx, Void ignored) {
        var c = challenge(List.of(g, ctx.R(), ctx.Y(), ctx.d(), pf.getA1(), pf.getA2()));

        var left1 = g.mul(pf.getR()).add(ctx.Y().mul(c)).normalize();
        var left2 = ctx.R().mul(pf.getR()).add(ctx.d().mul(c)).normalize();

        return left1.equals(pf.getA1()) && left2.equals(pf.getA2());
    }

    private BigInt challenge(List<WeierstrassPointOps<P>> pts) {
        var bytes = pts.stream().map(p -> p.encode(true)).toArray(byte[][]::new);
        return new BigInt(1, Hash.sha256(Bytes.concat(bytes))).mod(q);
    }
}