package org.exploit.tss.proof.dleq;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.WeierstrassPointOps;
import org.exploit.tss.proof.ZKProofGenerator;
import org.exploit.tss.proof.model.DleqProof;
import org.exploit.tss.proof.model.context.DleqContext;
import org.exploit.tss.util.Bytes;
import org.exploit.tss.util.Hash;
import org.exploit.tss.util.ZKRandom;

import java.util.List;

@AllArgsConstructor
public class DleqProofGenerator<P extends WeierstrassPointOps<P>> implements ZKProofGenerator<DleqProof<P>, BigInt, DleqContext<P>> {
    private final BigInt q;
    private final WeierstrassPointOps<P> g;

    @Override
    public DleqProof<P> createProof(BigInt secretXi, DleqContext<P> ctx) {
        var rnd = ZKRandom.getRandom();
        var k = new BigInt(q.bitLength(), rnd).mod(q);

        var A1 = g.mul(k);
        var A2 = ctx.R().mul(k);

        var c = challenge(List.of(g, ctx.R(), ctx.Y(), ctx.d(), A1, A2));

        var r = k.subtract(c.multiplySec(secretXi)).mod(q);

        return new DleqProof<>(A1.normalize(), A2.normalize(), r);
    }

    private BigInt challenge(List<WeierstrassPointOps<P>> pts) {
        var bytes = pts.stream().map(p -> p.encode(true)).toArray(byte[][]::new);
        return new BigInt(1, Hash.sha256(Bytes.concat(bytes))).mod(q);
    }
}