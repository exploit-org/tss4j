package org.exploit.tss.proof.random;

import org.exploit.gmp.BigInt;
import org.exploit.tss.util.Bytes;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

public final class DeterministicRandom extends Random {
    private final MessageDigest md;
    private final byte[] seed;

    private long counter;

    private int pos = 0;
    private byte[] buf = new byte[0];

    public DeterministicRandom(BigInt N, BigInt w, String label, int i, byte[] ctx) {
        try {
            this.md = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(e);
        }

        var lab = label.getBytes(StandardCharsets.UTF_8);

        var nBits = N.bitLength();
        var nLen = (nBits + 7) / 8;
        var nb = N.toUnsignedByteArray(nLen);

        byte[] wb;
        if (w == null) {
            wb = new byte[0];
        } else {
            var wBits = w.bitLength();
            var wLen  = (wBits + 7) / 8;
            wb = w.toUnsignedByteArray(wLen);
        }

        var ib = new byte[]{(byte)(i>>>24),(byte)(i>>>16),(byte)(i>>>8),(byte)i};
        var cb = (ctx == null) ? new byte[0] : ctx;
        this.seed = md.digest(Bytes.encode(lab, nb, wb, ib, cb));
    }

    @Override
    public void nextBytes(byte[] out) {
        var off = 0;
        while (off < out.length) {
            if (pos >= buf.length) refill();
            var n = Math.min(out.length - off, buf.length - pos);
            System.arraycopy(buf, pos, out, off, n);
            pos += n; off += n;
        }
    }

    @Override
    protected int next(int bits) {
        int acc = 0;
        int need = (bits + 7) >>> 3;
        for (int i = 0; i < need; i++) {
            if (pos >= buf.length) refill();
            acc = (acc << 8) | (buf[pos++] & 0xFF);
        }
        int excess = (need << 3) - bits;
        return acc >>> excess;
    }

    private void refill() {
        md.update(seed);
        md.update(new byte[]{
                (byte)(counter>>>56),(byte)(counter>>>48),(byte)(counter>>>40),(byte)(counter>>>32),
                (byte)(counter>>>24),(byte)(counter>>>16),(byte)(counter>>>8),(byte)counter
        });
        buf = md.digest();
        pos = 0;
        counter++;
    }
}