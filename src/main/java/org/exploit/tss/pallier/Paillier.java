package org.exploit.tss.pallier;

import org.exploit.gmp.BigInt;
import org.exploit.gmp.util.PrimeNumberGenerator;
import org.exploit.tss.pallier.key.PaillierKeyPair;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.pallier.model.PaillierEncryption;
import org.exploit.tss.util.ZKRandom;

import static org.exploit.gmp.BigInt.ONE;

public class Paillier implements HomomorphicCipher {
    private final PaillierPublicKey publicKey;
    private final PaillierPrivateKey privateKey;
    private final BigInt n, nsq;

    public Paillier(PaillierKeyPair keyPair) {
        this(keyPair.publicKey(), keyPair.privateKey());
    }

    public Paillier(PaillierPublicKey pub, PaillierPrivateKey priv) {
        this.publicKey = pub;
        this.privateKey = priv;
        this.n = pub.n();
        this.nsq = pub.nsquare();
    }

    public PaillierPublicKey publicKey() {
        return publicKey;
    }

    public PaillierPrivateKey privateKey() {
        return privateKey;
    }

    @Override
    public BigInt encrypt(BigInt m) {
        return encryptWithRandomness(m).c();
    }

    public PaillierEncryption encryptWithRandomness(BigInt m) {
        if (m.signum() < 0 || m.compareTo(n) >= 0) {
            throw new IllegalArgumentException("Message should be in [0, n)");
        }

        BigInt r;
        do {
            r = new BigInt(publicKey.bitLength(), ZKRandom.getRandom());
        } while (r.compareTo(n) >= 0 || !r.gcd(n).equals(ONE));

        var gm = ONE.add(n.multiplySec(m));
        var rn = r.modPowSec(n, nsq);

        var c = gm.multiplySec(rn).mod(nsq);

        return new PaillierEncryption(c, r);
    }

    @Override
    public BigInt decrypt(BigInt c) {
        var uP = c.modPowSec(privateKey.lambdaP(), privateKey.p2());
        var uQ = c.modPowSec(privateKey.lambdaQ(), privateKey.q2());

        var u = uP.multiplySec(privateKey.q2())
                .multiplySec(privateKey.invQ2modP2())
                .add(uQ.multiplySec(privateKey.p2()).multiplySec(privateKey.invP2modQ2()))
                .mod(nsq);

        var l = u.subtract(ONE).divide(n);
        return l.multiplySec(privateKey.mu()).mod(n);
    }

    public static PaillierKeyPair generateKeyPair(int bitLength) {
        var pair = PrimeNumberGenerator.generateBlumPair(bitLength);
        var p = pair.p();
        var q = pair.q();

        if (!p.testBit(0) || !q.testBit(0))
            throw new IllegalStateException("not odd");

        if (p.and(BigInt.valueOf(3)).longValue() != 3)
            throw new IllegalStateException("p not ≡ 3 mod 4");
        if (q.and(BigInt.valueOf(3)).longValue() != 3)
            throw new IllegalStateException("q not ≡ 3 mod 4");

        var n = p.multiply(q);
        var lambda = lcm(p.subtract(ONE), q.subtract(ONE));

        var mu = lambda.modInverseSec(n);

        var pub = new PaillierPublicKey(n, n.add(ONE), bitLength);
        var priv = new PaillierPrivateKey(lambda, mu, p, q);

        return new PaillierKeyPair(pub, priv);
    }

    private static BigInt lcm(BigInt a, BigInt b) {
        return a.multiplySec(b).divide(a.gcd(b));
    }
}
