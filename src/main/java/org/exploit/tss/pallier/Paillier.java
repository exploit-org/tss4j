package org.exploit.tss.pallier;

import org.exploit.gmp.BigInt;
import org.exploit.gmp.util.PrimeNumberGenerator;
import org.exploit.tss.pallier.key.PaillierKeyPair;
import org.exploit.tss.pallier.key.PaillierPrivateKey;
import org.exploit.tss.pallier.key.PaillierPublicKey;
import org.exploit.tss.pallier.model.PaillierEncryption;
import org.exploit.tss.util.ZKRandom;

import static org.exploit.gmp.BigInt.ONE;

public class Paillier implements HomomorphicCipher {
    private final PaillierPublicKey publicKey;
    private final PaillierPrivateKey privateKey;
    private final BigInt n, nsq;

    public Paillier(PaillierKeyPair keyPair) {
        this(keyPair.publicKey(), keyPair.privateKey());
    }

    public Paillier(PaillierPublicKey pub, PaillierPrivateKey priv) {
        this.publicKey = pub;
        this.privateKey = priv;
        this.n = pub.n();
        this.nsq = pub.nsquare();
    }

    public PaillierPublicKey publicKey() {
        return publicKey;
    }

    public PaillierPrivateKey privateKey() {
        return privateKey;
    }

    @Override
    public BigInt encrypt(BigInt m) {
        return encryptWithRandomness(m).c();
    }

    public PaillierEncryption encryptWithRandomness(BigInt m) {
        if (m.signum() < 0 || m.compareTo(n) >= 0) {
            throw new IllegalArgumentException("Message should be in [0, n)");
        }

        BigInt r;
        do {
            r = new BigInt(publicKey.bitLength(), ZKRandom.getRandom());
        } while (r.compareTo(n) >= 0 || !r.gcd(n).equals(ONE));

        var gm = ONE.add(n.multiply(m));
        var rn = r.modPow(n, nsq);

        var c = gm.multiply(rn).mod(nsq);

        return new PaillierEncryption(c, r);
    }

    @Override
    public BigInt decrypt(BigInt c) {
        var uP = c.modPow(privateKey.lambdaP(), privateKey.p2());
        var uQ = c.modPow(privateKey.lambdaQ(), privateKey.q2());

        var u = uP.multiply(privateKey.q2())
                .multiply(privateKey.invQ2modP2())
                .add(uQ.multiply(privateKey.p2()).multiply(privateKey.invP2modQ2()))
                .mod(nsq);

        var l = u.subtract(ONE).divide(n);
        return l.multiply(privateKey.mu()).mod(n);
    }

    public static PaillierKeyPair generateKeyPair(int bitLength) {
        var p = PrimeNumberGenerator.generate(bitLength / 2);
        var q = PrimeNumberGenerator.generate(bitLength / 2);

        var n = p.multiply(q);
        var lambda = lcm(p.subtract(ONE), q.subtract(ONE));

        var mu = lambda.modInverse(n);

        var pub = new PaillierPublicKey(n, n.add(ONE), bitLength);
        var priv = new PaillierPrivateKey(lambda, mu, p, q);

        return new PaillierKeyPair(pub, priv);
    }

    private static BigInt lcm(BigInt a, BigInt b) {
        return a.multiply(b).divide(a.gcd(b));
    }
}
