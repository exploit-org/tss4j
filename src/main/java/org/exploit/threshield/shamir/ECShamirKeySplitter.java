package org.exploit.threshield.shamir;

import lombok.Builder;
import org.exploit.threshield.curve.PointOps;
import org.exploit.threshield.shamir.model.ECKeyShare;
import org.exploit.threshield.shamir.model.ECKeySplitResult;
import org.exploit.zktrust.util.ZKRandom;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

@Builder(builderMethodName = "newBuilder")
public class ECShamirKeySplitter<P extends PointOps<P>> {
    private final BigInteger curveOrder;
    private final PointOps<P> generator;
    private final int threshold;
    private final int totalPeers;

    public ECShamirKeySplitter(BigInteger curveOrder, PointOps<P> generator, int threshold, int totalPeers) {
        if (threshold < 1 || threshold >= totalPeers) {
            throw new IllegalArgumentException("t should be between 1 и n-1");
        }

        this.curveOrder = curveOrder;
        this.generator = generator;
        this.threshold = threshold;
        this.totalPeers = totalPeers;
    }

    public ECKeySplitResult<P> splitKey(BigInteger sk) {
        var coefficients = new BigInteger[threshold + 1];
        coefficients[0] = sk;

        for (var i = 1; i <= threshold; i++) {
            coefficients[i] = new BigInteger(curveOrder.bitLength(), ZKRandom.getRandom()).mod(curveOrder);
        }

        var shares = new ArrayList<ECKeyShare<P>>(totalPeers);

        for (var i = 0; i < totalPeers; i++) {
            var x = BigInteger.valueOf(i + 1);
            var sk_i = evaluatePolynomial(coefficients, x);
            var pk_i = generator.mul(sk_i).normalize();
            shares.add(new ECKeyShare<>(i + 1, sk_i, pk_i));
        }

        var pk = generator.mul(sk).normalize();

        return new ECKeySplitResult<>(shares, pk);
    }

    public BigInteger recoverKey(List<ECKeyShare<P>> shares) {
        if (shares.size() < threshold + 1) {
            throw new IllegalArgumentException("Not enough shares для to restore key");
        }

        var sk = BigInteger.ZERO;

        for (var i = 0; i <= threshold; i++) {
            var y_i = shares.get(i).share();
            var l_i = lagrangeCoefficient(shares, i);

            sk = sk.add(y_i.multiply(l_i)).mod(curveOrder);
        }

        return sk;
    }

    private BigInteger evaluatePolynomial(BigInteger[] coeffs, BigInteger x) {
        var result = BigInteger.ZERO;
        var xPow = BigInteger.ONE;

        for (var coeff : coeffs) {
            result = result.add(coeff.multiply(xPow)).mod(curveOrder);
            xPow = xPow.multiply(x).mod(curveOrder);
        }

        return result;
    }

    private BigInteger lagrangeCoefficient(List<ECKeyShare<P>> shares, int j) {
        var x_j = BigInteger.valueOf(shares.get(j).index());
        var numerator = BigInteger.ONE;
        var denominator = BigInteger.ONE;

        for (var m = 0; m <= threshold; m++) {
            if (m != j) {
                var x_m = BigInteger.valueOf(shares.get(m).index());
                numerator = numerator.multiply(x_m.negate()).mod(curveOrder);
                denominator = denominator.multiply(x_j.subtract(x_m)).mod(curveOrder);
            }
        }

        var invDenom = denominator.modInverse(curveOrder);
        return numerator.multiply(invDenom).mod(curveOrder);
    }
}

