package org.exploit.threshield.ecdsa.signature;

import org.bouncycastle.math.ec.ECPoint;
import org.exploit.threshield.ecdsa.ThresholdECDSAClient;
import org.exploit.threshield.ecdsa.context.GG20Context;
import org.exploit.threshield.exception.ThresholdSecurityException;

import java.math.BigInteger;

public class PartialSignatureCalculator {
    private final GG20Context context;
    private final ThresholdECDSAClient client;

    public PartialSignatureCalculator(GG20Context context, ThresholdECDSAClient client) {
        this.context = context;
        this.client = client;
    }

    public void storeGamma(int peerId, ECPoint gamma) {
        var gammaCommitment = context.integrity().getGammaCommitment(peerId);

        if (gammaCommitment == null) {
            throw new ThresholdSecurityException(peerId, "Gamma commitment not found");
        }

        if (!client.generator().verifyGammaCommitment(gammaCommitment.C_i(), gamma, gammaCommitment.r_i())) {
            throw new ThresholdSecurityException(peerId, "Gamma commitment verification failed");
        }

        context.signature().storeGamma(peerId, gamma);
    }

    public BigInteger computeDeltaShare() {
        var commitment = context.crypto().ephemeral();
        var q = context.crypto().curve().q();
        var kG = commitment.k_i().multiply(commitment.gamma_i()).mod(q);

        return context.mta().respondent().modSumBeta(context.mta().initiator().modSumAlpha(kG, q), q);
    }

    public BigInteger computeSigmaShare() {
        var commitment = context.crypto().ephemeral();
        var q = context.crypto().curve().q();
        var kW = commitment.k_i().multiply(context.crypto().lagrangeShare()).mod(q);

        return context.mta().respondent().modSumNu(context.mta().initiator().modSumMu(kW, q), q);
    }

    public BigInteger computeSignatureR() {
        var gammaProduct = context.signature().computeGammaProduct(context.crypto().ephemeral().Gamma_i());
        var q = context.crypto().curve().q();
        var deltaInv = context.signature().computeDeltaSum(computeDeltaShare(), q).modInverse(q);
        var R = gammaProduct.multiply(deltaInv).normalize();

        return R.getAffineXCoord().toBigInteger().mod(q);
    }

    public BigInteger computePartialS() {
        var q = context.crypto().curve().q();
        var m = new BigInteger(1, context.init().message()).mod(q);
        var r = computeSignatureR();

        var ki = context.crypto().ephemeral().k_i();
        var sigmaI = computeSigmaShare();

        return ki.multiply(m).add(r.multiply(sigmaI)).mod(q);
    }
}
