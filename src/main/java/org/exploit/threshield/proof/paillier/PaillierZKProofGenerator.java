package org.exploit.threshield.proof.paillier;

import at.favre.lib.bytes.Bytes;
import org.exploit.crypto.Hash;
import org.exploit.gmp.BigInt;
import org.exploit.threshield.proof.ZKProofGenerator;
import org.exploit.threshield.proof.model.PaillierZKProof;
import org.exploit.threshield.proof.model.witness.PaillierEncryptionWitness;
import org.exploit.threshield.util.ZKRandom;

public class PaillierZKProofGenerator implements ZKProofGenerator<PaillierZKProof, PaillierEncryptionWitness, byte[]> {
    @Override
    public PaillierZKProof createProof(PaillierEncryptionWitness witness, byte[] context) {
        var pubKey = witness.publicKey();

        var alpha = new BigInt(pubKey.n().bitLength(), ZKRandom.getRandom()).mod(pubKey.n());

        BigInt beta;
        do {
            beta = new BigInt(pubKey.n().bitLength(), ZKRandom.getRandom());
        } while (beta.compareTo(pubKey.n()) >= 0 || !beta.gcd(pubKey.n()).equals(BigInt.ONE));

        var T = pubKey.g().modPow(alpha, pubKey.nsquare())
                .multiply(beta.modPow(pubKey.n(), pubKey.nsquare()))
                .mod(pubKey.nsquare());

        var hashInput = Bytes.from(
                pubKey.g().toByteArray(),
                witness.c().toByteArray(),
                T.toByteArray(),
                context
        ).array();

        var e = new BigInt(1, Hash.sha256(hashInput)).mod(pubKey.n());

        var s_m = alpha.add(e.multiply(witness.m()));
        var s_r = beta.multiply(witness.r().modPow(e, pubKey.n())).mod(pubKey.n());

        return new PaillierZKProof(T.toByteArray(), s_m, s_r);
    }
}