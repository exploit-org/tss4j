package org.exploit.threshield.hash;

import org.exploit.threshield.curve.EllipticCurveParams;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Objects;

public final class HashToScalar {
    private final EllipticCurveParams<?> curveParams;

    public HashToScalar(EllipticCurveParams<?> curveParams) {
        this.curveParams = Objects.requireNonNull(curveParams, "curveParams");
    }

    public BigInteger hash(byte[] domain, byte[]... msgs) {
        Objects.requireNonNull(domain, "domain");
        if (domain.length == 0 || domain.length > 255)
            throw new IllegalArgumentException("domain length must be 1..255 bytes");
        if (msgs == null || msgs.length == 0)
            throw new IllegalArgumentException("need at least one message");

        var totalLen = Arrays.stream(msgs).mapToInt(m -> Objects.requireNonNull(m).length).sum();
        var msg = new byte[totalLen];

        var off = 0;

        for (var part : msgs) {
            System.arraycopy(part, 0, msg, off, part.length);
            off += part.length;
        }

        var uniform = expandMessageXmd(msg, domain);
        var s = os2ip(uniform).mod(curveParams.getCurveOrder());

        if (s.signum() == 0) {
            var dom2 = Arrays.copyOf(domain, domain.length + 1);
            dom2[domain.length] = 1;
            uniform = expandMessageXmd(msg, dom2);
            s = os2ip(uniform).mod(curveParams.getCurveOrder());

            if (s.signum() == 0)
                throw new IllegalStateException("Hash‑to‑scalar produced zero twice");
        }
        return s;
    }

    private static BigInteger os2ip(byte[] src) {
        return new BigInteger(1, src);
    }

    private byte[] expandMessageXmd(byte[] msg, byte[] dst) {
        var xmdParams = curveParams.selectXmdParams();
        var md = xmdParams.newDigest();
        var b = md.getDigestLength();
        var ell = (int) Math.ceil((double) xmdParams.lenOut() / b);

        if (ell > 255)
            throw new IllegalArgumentException("ell > 255");

        var dstPrime = Arrays.copyOf(dst, dst.length + 1);
        dstPrime[dst.length] = (byte) dst.length;

        var zPad = new byte[b];

        md.update(zPad);
        md.update(msg);
        md.update((byte) (xmdParams.lenOut() >> 8));
        md.update((byte) xmdParams.lenOut());
        md.update((byte) 0x00);
        md.update(dstPrime);

        var b0 = md.digest();

        var bi = new byte[ell * b];
        byte[] biPrev = null;
        for (var i = 1; i <= ell; i++) {
            md.reset();
            byte[] input;
            if (i == 1) {
                input = concat(b0, new byte[]{1}, dstPrime);
            } else {
                var t = xor(b0, biPrev);
                input = concat(t, new byte[]{(byte) (i)}, dstPrime);
            }
            md.update(input);
            biPrev = md.digest();
            System.arraycopy(biPrev, 0, bi, (i - 1) * b, b);
        }

        return Arrays.copyOf(bi, xmdParams.lenOut());
    }

    private static byte[] concat(byte[]... arrs) {
        var len = Arrays.stream(arrs).mapToInt(a -> a.length).sum();
        var out = new byte[len];
        var pos = 0;

        for (var a : arrs) {
            System.arraycopy(a, 0, out, pos, a.length);
            pos += a.length;
        }
        return out;
    }

    private static byte[] xor(byte[] a, byte[] b) {
        var out = new byte[a.length];

        for (var i = 0; i < a.length; i++)
            out[i] = (byte) (a[i] ^ b[i]);

        return out;
    }
}
