package org.exploit.ed25519;

import lombok.AllArgsConstructor;
import org.exploit.gmp.BigInt;
import org.exploit.tss.curve.ec.ECPointOps;
import org.exploit.sodium.Sodium;

import java.util.Arrays;
import java.util.HexFormat;

import static org.exploit.tss.util.Endian.toLittleEndian;

@AllArgsConstructor
public class Ed25519PointOps implements ECPointOps<Ed25519PointOps> {
    private final byte[] encoded;

    @Override
    public Ed25519PointOps add(Ed25519PointOps q) {
        var r = new byte[Sodium.crypto_core_ed25519_BYTES];
        var res = Sodium.INSTANCE.crypto_core_ed25519_add(r, this.encoded, q.encoded);

        if (res != 0)
            throw new IllegalStateException("Error while adding points");

        return new Ed25519PointOps(r);
    }

    @Override
    public Ed25519PointOps dbl() {
        return this.add(this);
    }

    @Override
    public Ed25519PointOps mul(BigInt k) {
        return mulUnclamped(k);
    }

    @Override
    public Ed25519PointOps sub(Ed25519PointOps q) {
        var r = new byte[Sodium.crypto_core_ed25519_BYTES];
        var res = Sodium.INSTANCE.crypto_core_ed25519_sub(r, this.encoded, q.encoded);

        if (res != 0) {
            throw new IllegalStateException("Error while subtracting points");
        }

        return new Ed25519PointOps(r);
    }

    public Ed25519PointOps mulClamped(BigInt k) {
        if (k == null) throw new IllegalArgumentException("Scalar cannot be null");

        if (k.signum() == 0) {
            var id = new byte[Sodium.crypto_core_ed25519_BYTES];
            id[0] = 1;
            return new Ed25519PointOps(id);
        }

        var n = toLittleEndian(k, Sodium.crypto_scalarmult_ed25519_SCALARBYTES);
        var q = new byte[Sodium.crypto_scalarmult_ed25519_BYTES];

        var res = Sodium.INSTANCE.crypto_scalarmult_ed25519(q, n, this.encoded);

        if (res != 0)
            throw new IllegalStateException("Error in clamped scalar multiplication");

        return new Ed25519PointOps(q);
    }

    public Ed25519PointOps mulUnclamped(BigInt k) {
        if (k == null)
            throw new IllegalArgumentException("Scalar cannot be null");

        if (k.signum() == 0) {
            var id = new byte[Sodium.crypto_core_ed25519_BYTES];
            id[0] = 1;
            return new Ed25519PointOps(id);
        }

        var n = toLittleEndian(k, Sodium.crypto_scalarmult_ed25519_SCALARBYTES);
        var q = new byte[Sodium.crypto_scalarmult_ed25519_BYTES];
        var res = Sodium.INSTANCE.crypto_scalarmult_ed25519_noclamp(q, n, this.encoded);

        if (res != 0)
            throw new IllegalStateException("Error in unclamped scalar multiplication");

        return new Ed25519PointOps(q);
    }

    @Override
    public Ed25519PointOps normalize() {
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Ed25519PointOps)) return false;
        return Arrays.equals(encoded, ((Ed25519PointOps)o).encoded);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(encoded);
    }

    @Override
    public String toString() {
        return HexFormat.of().formatHex(encoded);
    }

    @Override
    public Ed25519PointOps negate() {
        var r = this.encoded.clone();
        r[Sodium.crypto_core_ed25519_BYTES - 1] ^= (byte) 0x80;

        return new Ed25519PointOps(r);
    }

    @Override
    public boolean isValid() {
        return Sodium.INSTANCE.crypto_core_ed25519_is_valid_point(encoded) == 1;
    }

    @Override
    public byte[] encode(boolean compressed) {
        return encoded.clone();
    }

    public static Ed25519PointOps baseMulClamped(BigInt k) {
        if (k == null) throw new IllegalArgumentException("Scalar cannot be null");

        if (k.signum() == 0) {
            var id = new byte[Sodium.crypto_core_ed25519_BYTES];
            id[0] = 1;
            return new Ed25519PointOps(id);
        }

        var n = toLittleEndian(k, Sodium.crypto_scalarmult_ed25519_SCALARBYTES);
        var q = new byte[Sodium.crypto_scalarmult_ed25519_BYTES];

        var res = Sodium.INSTANCE.crypto_scalarmult_ed25519_base(q, n);

        if (res != 0)
            throw new IllegalStateException("Error in clamped base multiplication");

        return new Ed25519PointOps(q);
    }

    public static Ed25519PointOps baseMulUnclamped(BigInt k) {
        if (k == null) throw new IllegalArgumentException("Scalar cannot be null");

        if (k.signum() == 0) {
            var id = new byte[Sodium.crypto_core_ed25519_BYTES];
            id[0] = 1;
            return new Ed25519PointOps(id);
        }

        var n = toLittleEndian(k, Sodium.crypto_scalarmult_ed25519_SCALARBYTES);
        var q = new byte[Sodium.crypto_scalarmult_ed25519_BYTES];

        var res = Sodium.INSTANCE.crypto_scalarmult_ed25519_base_noclamp(q, n);

        if (res != 0)
            throw new IllegalStateException("Error in unclamped base multiplication");

        return new Ed25519PointOps(q);
    }

    public static Ed25519PointOps fromUniform(byte[] uniform) {
        if (uniform.length != Sodium.crypto_core_ed25519_UNIFORMBYTES) {
            throw new IllegalArgumentException("Wrong length of uniform buffer");
        }

        var p = new byte[Sodium.crypto_core_ed25519_BYTES];
        var res = Sodium.INSTANCE.crypto_core_ed25519_from_uniform(p, uniform);

        if (res != 0)
            throw new IllegalStateException("Error while converting uniform to point");

        return new Ed25519PointOps(p);
    }

    public static Ed25519PointOps fromBytes(byte[] buf) {
        if (buf.length != Sodium.crypto_core_ed25519_BYTES) {
            throw new IllegalArgumentException("Wrong length of point buffer");
        }
        return new Ed25519PointOps(buf);
    }

    public static Ed25519PointOps random() {
        var p = new byte[Sodium.crypto_core_ed25519_BYTES];
        Sodium.INSTANCE.crypto_core_ed25519_random(p);
        return new Ed25519PointOps(p);
    }
}
