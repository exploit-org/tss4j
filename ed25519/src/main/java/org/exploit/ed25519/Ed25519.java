package org.exploit.ed25519;

import org.exploit.sodium.Sodium;

import java.util.Arrays;

public final class Ed25519 {
    private Ed25519() {}

    static {
        if (Sodium.INSTANCE.sodium_init() < 0) {
            throw new IllegalStateException("libsodium init failed");
        }
    }

    public static RawEd25519KeyPair generateKeyPair() {
        var seed = new byte[Sodium.crypto_sign_ed25519_SEEDBYTES];
        Sodium.INSTANCE.randombytes_buf(seed, seed.length);

        var pk = new byte[Sodium.crypto_sign_ed25519_PUBLICKEYBYTES];
        var fullSk = new byte[Sodium.crypto_sign_ed25519_SECRETKEYBYTES];

        if (Sodium.INSTANCE.crypto_sign_ed25519_seed_keypair(pk, fullSk, seed) != 0) {
            throw new IllegalStateException("Key pair generation failed");
        }

        return new RawEd25519KeyPair(pk, seed);
    }

    public static byte[] signDetached(byte[] message, byte[] seed) {
        var keyPair = fromSeed(seed);
        return signDetachedWithFullSk(message, keyPair.getFullSecretKey());
    }

    private static byte[] signDetachedWithFullSk(byte[] message, byte[] sk) {
        var sig = new byte[Sodium.crypto_sign_ed25519_BYTES];
        var siglen = new long[1];
        if (Sodium.INSTANCE.crypto_sign_ed25519_detached(sig, siglen, message, message.length, sk) != 0) {
            throw new IllegalStateException("Signing failed");
        }
        if (siglen[0] != sig.length) {
            throw new IllegalStateException("Unexpected signature length: " + siglen[0]);
        }
        return sig;
    }

    public static boolean verifyDetached(byte[] message, byte[] signature, byte[] publicKey) {
        return Sodium.INSTANCE.crypto_sign_ed25519_verify_detached(
            signature, message, message.length, publicKey
        ) == 0;
    }

    public static byte[] sign(byte[] message, byte[] seed) {
        var keyPair = fromSeed(seed);
        return signWithFullSk(message, keyPair.getFullSecretKey());
    }

    private static byte[] signWithFullSk(byte[] message, byte[] secretKey) {
        var smlen = new long[1];
        var sm = new byte[Sodium.crypto_sign_ed25519_BYTES + message.length];

        if (Sodium.INSTANCE.crypto_sign_ed25519(sm, smlen, message, message.length, secretKey) != 0) {
            throw new IllegalStateException("Full signing failed");
        }

        return Arrays.copyOf(sm, (int) smlen[0]);
    }

    public static byte[] open(byte[] signedMessage, byte[] publicKey) {
        var mlen = new long[1];
        var m = new byte[signedMessage.length];

        if (Sodium.INSTANCE.crypto_sign_ed25519_open(m, mlen, signedMessage, signedMessage.length, publicKey) != 0) {
            throw new IllegalStateException("Signature verification failed");
        }

        return Arrays.copyOf(m, (int) mlen[0]);
    }

    public static RawEd25519KeyPair fromSeed(byte[] seed) {
        if (seed == null || seed.length != Sodium.crypto_sign_ed25519_SEEDBYTES)
            throw new IllegalArgumentException("Seed must be 32 bytes");

        var pk = new byte[Sodium.crypto_sign_ed25519_PUBLICKEYBYTES];
        var sk = new byte[Sodium.crypto_sign_ed25519_SECRETKEYBYTES];

        if (Sodium.INSTANCE.crypto_sign_ed25519_seed_keypair(pk, sk, seed) != 0) {
            throw new IllegalStateException("Seed RawKeyPair generation failed");
        }

        Arrays.fill(sk, 0, Sodium.crypto_sign_ed25519_SECRETKEYBYTES, (byte) 0);

        return new RawEd25519KeyPair(pk, seed);
    }
}