package org.exploit.gmp;

import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import org.exploit.gmp.jna.GMP;

import javax.security.auth.Destroyable;
import java.lang.ref.Cleaner;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;

public class BigInt implements Destroyable, Comparable<BigInt> {
    private static final Cleaner CLEANER = Cleaner.create();

    public static final BigInt ZERO;
    public static final BigInt ONE;
    public static final BigInt TWO;
    public static final BigInt TEN;

    static {
        ZERO = new BigInt();

        ONE = new BigInt();
        GMP.INSTANCE.__gmpz_set_si(ONE.value, 1);

        TWO = new BigInt();
        GMP.INSTANCE.__gmpz_set_si(TWO.value, 2);

        TEN = new BigInt();
        GMP.INSTANCE.__gmpz_set_si(TEN.value, 10);
    }

    private boolean destroyed = false;

    private final GMP.mpz_t value;
    private final Cleaner.Cleanable cleanable;

    public BigInt() {
        value = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(value);
        GMP.INSTANCE.__gmpz_set_si(value, 0);

        cleanable = CLEANER.register(this, new BigNumCleanup(value));
    }

    public BigInt(String val, int radix) {
        value = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(value);
        cleanable = CLEANER.register(this, new BigNumCleanup(value));

        if (GMP.INSTANCE.__gmpz_set_str(value, val, radix) != 0) {
            GMP.INSTANCE.__gmpz_clear(value);
            throw new NumberFormatException("Invalid number: " + val);
        }
    }

    public BigInt(String val) {
        this(val, 10);
    }

    public BigInt(int numBits, SecureRandom rnd) {
        if (numBits < 0)
            throw new IllegalArgumentException("numBits must be nonâ€‘negative");

        value = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(value);
        cleanable = CLEANER.register(this, new BigNumCleanup(value));

        if (numBits == 0) {
            GMP.INSTANCE.__gmpz_set_si(value, 0);
            return;
        }

        var byteLen = (numBits + 7) / 8;
        var bytes = new byte[byteLen];
        rnd.nextBytes(bytes);
        var excessBits = byteLen * 8 - numBits;
        bytes[0] &= (byte) (0xFF >>> excessBits);

        if ((bytes[0] & 0x80) != 0)
            bytes[0] &= 0x7F;

        var mem = new Memory(byteLen);
        mem.write(0, bytes, 0, byteLen);
        GMP.INSTANCE.__gmpz_import(value, new NativeLong(byteLen), 1, new NativeLong(1), 0, new NativeLong(0), mem);
    }


    public BigInt(byte[] val) {
        value = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(value);

        cleanable = CLEANER.register(this, new BigNumCleanup(value));
        if (val.length == 0) {
            GMP.INSTANCE.__gmpz_set_si(value, 0);
            return;
        }
        var negative = (val[0] & 0x80) != 0;
        var mem = new Memory(val.length);
        mem.write(0, val, 0, val.length);
        GMP.INSTANCE.__gmpz_import(value, new NativeLong(val.length), 1, new NativeLong(1), 0, new NativeLong(0), mem);

        if (negative) {
            var pow2 = new GMP.mpz_t();
            GMP.INSTANCE.__gmpz_init(pow2);
            GMP.INSTANCE.__gmpz_set_si(pow2, 1);
            GMP.INSTANCE.__gmpz_mul_2exp(pow2, pow2, val.length * 8L);
            GMP.INSTANCE.__gmpz_sub(value, value, pow2);
            GMP.INSTANCE.__gmpz_clear(pow2);
        }
    }

    public BigInt(int signum, byte[] magnitude) {
        if (signum < -1 || signum > 1) {
            throw new NumberFormatException("Invalid signum: " + signum);
        }

        value = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(value);
        cleanable = CLEANER.register(this, new BigNumCleanup(value));
        if (signum == 0 || magnitude.length == 0) {
            GMP.INSTANCE.__gmpz_set_si(value, 0);
            return;
        }
        var mem = new Memory(magnitude.length);
        mem.write(0, magnitude, 0, magnitude.length);
        GMP.INSTANCE.__gmpz_import(value, new NativeLong(magnitude.length), 1, new NativeLong(1), 0, new NativeLong(0), mem);
        if (signum == -1) {
            GMP.INSTANCE.__gmpz_neg(value, value);
        }
    }

    public boolean testBit(int n) {
        if (n < 0) {
            throw new ArithmeticException("Negative bit index");
        }

        return GMP.INSTANCE.__gmpz_tstbit(this.value, n) != 0;
    }

    public BigInt add(BigInt other) {
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_add(result.value, this.value, other.value);
        return result;
    }

    public BigInt subtract(BigInt other) {
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_sub(result.value, this.value, other.value);
        return result;
    }

    public BigInt multiply(BigInt other) {
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_mul(result.value, this.value, other.value);
        return result;
    }

    public BigInt divide(BigInt other) {
        if (GMP.INSTANCE.__gmpz_cmp_si(other.value, 0) == 0) {
            throw new ArithmeticException("Division by zero");
        }
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_tdiv_q(result.value, this.value, other.value);
        return result;
    }

    public BigInt remainder(BigInt other) {
        if (GMP.INSTANCE.__gmpz_cmp_si(other.value, 0) == 0) {
            throw new ArithmeticException("Division by zero");
        }
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_tdiv_r(result.value, this.value, other.value);
        return result;
    }

    public BigInt pow(int exponent) {
        if (exponent < 0) {
            throw new ArithmeticException("Negative exponent");
        }
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_pow_ui(result.value, this.value, exponent);
        return result;
    }

    public BigInt modPow(BigInt exponent, BigInt modulus) {
        if (GMP.INSTANCE.__gmpz_cmp_si(modulus.value, 0) <= 0) {
            throw new ArithmeticException("Modulus must be positive");
        }
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_powm(result.value, this.value, exponent.value, modulus.value);
        return result;
    }


    public BigInt mod(BigInt m) {
        if (GMP.INSTANCE.__gmpz_cmp_si(m.value, 0) <= 0) {
            throw new ArithmeticException("Modulus must be positive");
        }
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_mod(result.value, this.value, m.value);
        return result;
    }

    public BigInt gcd(BigInt other) {
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_gcd(result.value, this.value, other.value);
        return result;
    }

    public boolean isProbablePrime(int certainty) {
        var reps = certainty / 2;
        if (reps < 1) reps = 1;
        return GMP.INSTANCE.__gmpz_probab_prime_p(this.value, reps) != 0;
    }

    public BigInt negate() {
        var result = new BigInt();
        GMP.INSTANCE.__gmpz_neg(result.value, this.value);
        return result;
    }

    @Override
    public int compareTo(BigInt other) {
        return GMP.INSTANCE.__gmpz_cmp(this.value, other.value);
    }

    public byte[] toByteArray() {
        var cmp = GMP.INSTANCE.__gmpz_cmp_si(value, 0);
        if (cmp == 0) {
            return new byte[]{0};
        }
        var negative = cmp < 0;
        var absValue = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(absValue);
        GMP.INSTANCE.__gmpz_abs(absValue, value);

        var bitLength = GMP.INSTANCE.__gmpz_sizeinbase(absValue, 2);
        var byteLength = (bitLength + 7) / 8;
        var mem = new Memory(byteLength);

        var countp = new IntByReference();

        GMP.INSTANCE.__gmpz_export(mem, countp, 1, 1, 0, 0, absValue);
        var count = countp.getValue();
        var bytes = mem.getByteArray(0, count);
        if (count < byteLength) {
            var padded = new byte[byteLength];
            System.arraycopy(bytes, 0, padded, byteLength - count, count);
            bytes = padded;
        }
        if (negative) {
            for (var i = 0; i < bytes.length; i++) {
                bytes[i] = (byte) ~bytes[i];
            }
            var carry = 1;
            for (var i = bytes.length - 1; i >= 0; i--) {
                var sum = (bytes[i] & 0xFF) + carry;
                bytes[i] = (byte) sum;
                carry = sum >> 8;
            }
            if ((bytes[0] & 0x80) == 0) {
                var newBytes = new byte[bytes.length + 1];
                newBytes[0] = (byte) 0xFF;
                System.arraycopy(bytes, 0, newBytes, 1, bytes.length);
                bytes = newBytes;
            }
        } else {
            if ((bytes[0] & 0x80) != 0) {
                var newBytes = new byte[bytes.length + 1];
                System.arraycopy(bytes, 0, newBytes, 1, bytes.length);
                bytes = newBytes;
            }
        }
        GMP.INSTANCE.__gmpz_clear(absValue);
        return bytes;
    }

    @Override
    public String toString() {
        var ptr = GMP.INSTANCE.__gmpz_get_str(null, 10, value);
        var result = ptr.getString(0);
        Native.free(Pointer.nativeValue(ptr));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof BigInt)) return false;
        var other = (BigInt) obj;
        return GMP.INSTANCE.__gmpz_cmp(this.value, other.value) == 0;
    }

    public BigInt modInverse(BigInt m) {
        if (GMP.INSTANCE.__gmpz_cmp_si(m.value, 0) <= 0)
            throw new ArithmeticException("Modulus must be positive");

        BigInt res = new BigInt();
        int ok = GMP.INSTANCE.__gmpz_invert(res.value, this.value, m.value);
        if (ok == 0) throw new ArithmeticException("Inverse does not exist");

        if (GMP.INSTANCE.__gmpz_cmp_si(res.value, 0) < 0) {
            GMP.INSTANCE.__gmpz_add(res.value, res.value, m.value);
        }
        return res;
    }

    public int bitLength() {
        if (GMP.INSTANCE.__gmpz_cmp_si(value, 0) == 0) return 0;
        if (GMP.INSTANCE.__gmpz_cmp_si(value, 0) > 0) {
            return GMP.INSTANCE.__gmpz_sizeinbase(value, 2);
        }
        var tmp = new GMP.mpz_t();
        GMP.INSTANCE.__gmpz_init(tmp);
        GMP.INSTANCE.__gmpz_neg(tmp, value);
        GMP.INSTANCE.__gmpz_sub_ui(tmp, tmp, 1);
        var bits = GMP.INSTANCE.__gmpz_sizeinbase(tmp, 2);
        GMP.INSTANCE.__gmpz_clear(tmp);
        return bits;
    }

    public BigInt shiftLeft(int n) {
        if (n < 0) return shiftRight(-n);
        BigInt result = new BigInt();
        GMP.INSTANCE.__gmpz_mul_2exp(result.value, this.value, n);
        return result;
    }

    public BigInt shiftRight(int n) {
        if (n < 0) return shiftLeft(-n);
        BigInt result = new BigInt();

        GMP.INSTANCE.__gmpz_fdiv_q_2exp(result.value, this.value, n);
        return result;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(toByteArray());
    }

    public int signum() {
        return GMP.INSTANCE.__gmpz_cmp_si(value, 0);
    }

    public BigInteger toJavaInt() {
        return new BigInteger(toByteArray());
    }

    @Override
    public boolean isDestroyed() {
        return destroyed;
    }

    @Override
    public void destroy() {
        cleanable.clean();
        destroyed = true;
    }

    public static BigInt valueOf(long val) {
        switch ((int) val) {
            case 0: return ZERO;
            case 1: return ONE;
            case 2: return TWO;
            case 10: return TEN;
            default:
                var result = new BigInt();
                GMP.INSTANCE.__gmpz_set_si(result.value, val);
                return result;
        }
    }

    private static class BigNumCleanup implements Runnable {
        private final GMP.mpz_t value;

        BigNumCleanup(GMP.mpz_t value) {
            this.value = value;
        }

        @Override
        public void run() {
            GMP.INSTANCE.__gmpz_clear(value);
        }
    }
}