package org.exploit.gmp.util;

import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import org.exploit.gmp.jna.GMP;
import org.exploit.gmp.jna.Mpz;
import org.exploit.gmp.BigInt;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.Executors;

public final class PrimeNumberGenerator {
    private PrimeNumberGenerator() {}

    public static final ThreadLocal<SecureRandom> CSPRNG = ThreadLocal.withInitial(() -> {
        try {
            return SecureRandom.getInstanceStrong();
        } catch (Exception e) {
            return new SecureRandom();
        }
    });

    public static BigInt generate(int bitLength) {
        return generate(bitLength, Math.max(1, Runtime.getRuntime().availableProcessors() / 2));
    }

    public static BigInt generate(int bitlength, int threads) {
        if (threads <= 0) threads = 1;

        var pool = Executors.newFixedThreadPool(threads, PrimeNumberGenerator::newWorker);

        try {
            CompletionService<BigInt> ecs = new ExecutorCompletionService<>(pool);
            for (var i = 0; i < threads; i++) ecs.submit(() -> generateSingle(bitlength));
            try {
                return ecs.take().get();
            } catch (ExecutionException e) {
                throw new IllegalStateException("prime generation failed", e.getCause());
            }
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new IllegalArgumentException("interrupted", ie);
        } catch (Exception e) {
            throw new IllegalStateException("unexpected error", e);
        } finally {
            pool.shutdownNow();
        }
    }

    private static void setTopBit(byte[] b, int bits) {
        var topBits = bits & 7;
        if (topBits == 0) {
            b[0] |= (byte) 0x80;
        } else {
            var mask = (1 << topBits) - 1;
            b[0] &= (byte) mask;
            b[0] |= (byte) (1 << (topBits - 1));
        }
    }

    private static Thread newWorker(Runnable r) {
        var t = new Thread(r, "PrimeGen-worker");
        t.setDaemon(true);
        return t;
    }

    private static BigInt generateSingle(int bits) {
        var rng = CSPRNG.get();
        var byteLen = (bits + 7) >>> 3;

        try (var n = new Mpz(); var p = new Mpz()) {
            var bufMem = new Memory(byteLen);
            var buf = new byte[byteLen];
            var countRef = new IntByReference();

            while (!Thread.currentThread().isInterrupted()) {
                rng.nextBytes(buf);
                setTopBit(buf, bits);
                buf[byteLen - 1] |= 0x01;

                bufMem.write(0, buf, 0, byteLen);
                GMP.INSTANCE.__gmpz_import(n, new NativeLong(byteLen), 1, new NativeLong(1), 1, new NativeLong(0), bufMem);

                GMP.INSTANCE.__gmpz_nextprime(p, n);
                if (GMP.INSTANCE.__gmpz_sizeinbase(p, 2) != bits) continue;

                var outPtr = GMP.INSTANCE.__gmpz_export(Pointer.NULL, countRef, 1, 1, 1, 0, p);
                var count = countRef.getValue();
                var out = outPtr.getByteArray(0, count);
                Native.free(Pointer.nativeValue(outPtr));

                return new BigInt(1, out);
            }

            throw new InterruptedException();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("worker interrupted", ie);
        }
    }

    public static boolean isPrime(BigInteger n) {
        try (var z = new Mpz()) {
            GMP.INSTANCE.__gmpz_set_str(z, n.toString(16), 16);
            return GMP.INSTANCE.__gmpz_probab_prime_p(z, 25) >= 1;
        }
    }

    public static BlumPair generateBlumPair(int bitLength) {
        return generateBlumPair(bitLength, Math.max(1, Runtime.getRuntime().availableProcessors()));
    }

    public static BigInt generateBlum(int bitLength, int threads) {
        if (threads <= 0) threads = 1;
        var pool = Executors.newFixedThreadPool(threads, PrimeNumberGenerator::newWorker);
        try {
            var ecs = new ExecutorCompletionService<BigInt>(pool);
            for (int i = 0; i < threads; i++) {
                final int bits = bitLength;
                ecs.submit(() -> generateSingleBlum(bits));
            }
            return ecs.take().get();
        } catch (ExecutionException e) {
            throw new IllegalStateException("blum prime generation failed", e.getCause());
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new IllegalArgumentException("interrupted", ie);
        } finally {
            pool.shutdownNow();
        }
    }

    public static BlumPair generateBlumPair(int bitLength, int threads) {
        if (threads <= 0) threads = 1;
        final int half = bitLength >>> 1;

        var pool = Executors.newFixedThreadPool(threads, PrimeNumberGenerator::newWorker);
        try {
            var ecs = new ExecutorCompletionService<BigInt>(pool);

            int tasks = Math.max(2 * threads, threads + 2);
            for (int i = 0; i < tasks; i++) {
                ecs.submit(() -> generateSingleBlum(half));
            }

            BigInt p = null, q = null;
            while (true) {
                BigInt cand = ecs.take().get();
                if (p == null) {
                    p = cand;
                } else if (!cand.equals(p)) {
                    q = cand;
                    break;
                } else {
                    ecs.submit(() -> generateSingleBlum(half));
                }
            }
            return new BlumPair(p, q);
        } catch (ExecutionException e) {
            throw new IllegalStateException("blum pair generation failed", e.getCause());
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new IllegalArgumentException("interrupted", ie);
        } finally {
            pool.shutdownNow();
        }
    }
    public static BigInt generateBlum(int bitLength) {
        return generateBlum(bitLength, Math.max(1, Runtime.getRuntime().availableProcessors() / 2));
    }

    public record BlumPair(BigInt p, BigInt q) {}

    private static BigInt generateSingleBlum(int bits) {
        var rng = CSPRNG.get();
        final int byteLen = (bits + 7) >>> 3;

        try (var cand = new Mpz(); var upper = new Mpz()) {
            GMP.INSTANCE.__gmpz_set_ui(upper, 0);
            GMP.INSTANCE.__gmpz_setbit(upper, bits);

            final byte[] buf = new byte[byteLen];
            final Memory bufMem = new Memory(byteLen);

            final Memory outMem = new Memory(byteLen);
            final IntByReference countRef = new IntByReference();

            while (!Thread.currentThread().isInterrupted()) {
                rng.nextBytes(buf);
                setTopBit(buf, bits);
                buf[byteLen - 1] |= 0x03;

                bufMem.write(0, buf, 0, byteLen);
                GMP.INSTANCE.__gmpz_import(
                        cand,
                        new NativeLong(byteLen),
                        1, new NativeLong(1), 1, new NativeLong(0),
                        bufMem
                );

                while (GMP.INSTANCE.__gmpz_cmp(cand, upper) < 0) {
                    if (GMP.INSTANCE.__gmpz_probab_prime_p(cand, 25) >= 1) {
                        GMP.INSTANCE.__gmpz_export(outMem, countRef, 1, 1, 1, 0, cand);
                        int count = countRef.getValue();

                        byte[] out = new byte[count];
                        outMem.read(0, out, 0, count);
                        return new BigInt(1, out);
                    }

                    GMP.INSTANCE.__gmpz_add_ui(cand, cand, 4);
                }
            }

            throw new InterruptedException();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("worker interrupted", ie);
        }
    }
}